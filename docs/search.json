[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Big book of my PhD",
    "section": "",
    "text": "This is the website for “Big book for my PhD” by Shamsuddeen Muhammad. This book contains resources, tips, recommdations based on my experience as a PhD student. I decided to put everything in this book and make it available to the public so that someone can read and benfit the experience or the resources.\n\n\n\n\n\n\nYou can visit my blog"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Big book of my PhD",
    "section": "License",
    "text": "License\nThis website is (and will always be) free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "This book will teach you how to program in R. You’ll go from loading data to writing your own functions (which will outperform the functions of other R users). But this is not a typical introduction to R. I want to help you become a data scientist, as well as a computer scientist, so this book will focus on the programming skills that are most related to data science.\nThe chapters in the book are arranged according to three practical projects–given that they’re fairly substantial projects, they span multiple chapters. I chose these projects for two reasons. First, they cover the breadth of the R language. You will learn how to load data, assemble and disassemble data objects, navigate R’s environment system, write your own functions, and use all of R’s programming tools, such as if else statements, for loops, S3 classes, R’s package system, and R’s debugging tools. The projects will also teach you how to write vectorized R code, a style of lightning-fast code that takes advantage of all of the things R does best.\nBut, more importantly, the projects will teach you how to solve the logistical problems of data science—and there are many logistical problems. When you work with data, you will need to store, retrieve, and manipulate large sets of values without introducing errors. As you work through the book, I will teach you not just how to program with R, but how to use the programming skills to support your work as a data scientist.\nNot every programmer needs to be a data scientist, so not every programmer will find this book useful. You will find this book helpful if you’re in one of the following categories:\nOne of the biggest surprises in this book is that I do not cover traditional applications of R, such as models and graphs; instead, I treat R purely as a programming language. Why this narrow focus? R is designed to be a tool that helps scientists analyze data. It has many excellent functions that make plots and fit models to data. As a result, many statisticians learn to use R as if it were a piece of software—they learn which functions do what they want, and they ignore the rest.\nThis is an understandable approach to learning R. Visualizing and modeling data are complicated skills that require a scientist’s full attention. It takes expertise, judgement, and focus to extract reliable insights from a data set. I would not recommend that any data scientist distract herself with computer programming until she feels comfortable with the basic theory and practice of her craft. If you would like to learn the craft of data science, I recommend the book R for Data Science, my companion volume to this book, co-written with Hadley Wickham.\nHowever, learning to program should be on every data scientist’s to-do list. Knowing how to program will make you a more flexible analyst and augment your mastery of data science in every way. My favorite metaphor for describing this was introduced by Greg Snow on the R help mailing list in May 2006. Using functions in R is like riding a bus. Writing functions in R is like driving a car.\nGreg compares R to SPSS, but he assumes that you use the full powers of R; in other words, that you learn how to program in R. If you only use functions that preexist in R, you are using R like SPSS: it is a bus that can only take you to certain places.\nThis flexibility matters to data scientists. The exact details of a method or simulation will change from problem to problem. If you cannot build a method tailored to your situation, you may find yourself tempted to make unrealistic assumptions just so you can use an ill-suited method that already exists.\nThis book will help you make the leap from bus to car. I have written it for beginning programmers. I do not talk about the theory of computer science—there are no discussions of big O() and little o() in these pages. Nor do I get into advanced details such as the workings of lazy evaluation. These things are interesting if you think of computer science at the theoretical level, but they are a distraction when you first learn to program.\nInstead, I teach you how to program in R with three concrete examples. These examples are short, easy to understand, and cover everything you need to know.\nI have taught this material many times in my job as Master Instructor at RStudio. As a teacher, I have found that students learn abstract concepts much faster when they are illustrated by concrete examples. The examples have a second advantage, as well: they provide immediate practice. Learning to program is like learning to speak another language—you progress faster when you practice. In fact, learning to program is learning to speak another language. You will get the best results if you follow along with the examples in the book and experiment whenever an idea strikes you.\nThe book is a companion to R for Data Science. In that book, Hadley Wickham and I explain how to use R to make plots, model data, and write reports. That book teaches these tasks as data-science skills, which require judgement and expertise—not as programming exercises, which they also are. This book will teach you how to program in R. It does not assume that you have mastered the data-science skills taught in R for Data Science (nor that you ever intend to). However, this skill set amplifies that one. And if you master both, you will be a powerful, computer-augmented data scientist, fit to command a high salary and influence scientific dialogue."
  },
  {
    "objectID": "preface.html#conventions-used-in-this-book",
    "href": "preface.html#conventions-used-in-this-book",
    "title": "Preface",
    "section": "Conventions Used in This Book",
    "text": "Conventions Used in This Book\nThe following typographical conventions are used in this book:\nItalic:: Indicates new terms, URLs, email addresses, filenames, and file extensions.\nConstant width:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.\nConstant width bold:: Shows commands or other text that should be typed literally by the user.\nConstant width italic:: Shows text that should be replaced with user-supplied values or by values determined by context.\nTo comment or ask technical questions about this book, please file an issue at github.com/rstudio-education/hopr."
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nMany excellent people have helped me write this book, from my two editors, Courtney Nash and Julie Steele, to the rest of the O’Reilly team, who designed, proofread, and indexed the book. Also, Greg Snow generously let me quote him in this preface. I offer them all my heartfelt thanks.\nI would also like to thank Hadley Wickham, who has shaped the way I think about and teach R. Many of the ideas in this book come from Statistics 405, a course that I helped Hadley teach when I was a PhD student at Rice University.\nFurther ideas came from the students and teachers of Introduction to Data Science with R, a workshop that I teach on behalf of RStudio. Thank you to all of you. I’d like to offer special thanks to my teaching assistants Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson, and Vivian Zhang.\nThank you also to JJ Allaire and the rest of my colleagues at RStudio who provide the RStudio IDE, a tool that makes it much easier to use, teach, and write about R.\nFinally, I would like to thank my wife, Kristin, for her support and understanding while I wrote this book."
  },
  {
    "objectID": "awosomewebsite.html",
    "href": "awosomewebsite.html",
    "title": "Resources",
    "section": "",
    "text": "As a data scientist who knows how to program, you will improve your ability to:\n\nMemorize (store) entire data sets\nRecall data values on demand\nPerform complex calculations with large amounts of data\nDo repetitive tasks without becoming careless or bored"
  },
  {
    "objectID": "softwares.html",
    "href": "softwares.html",
    "title": "1  Softwares",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "books.html",
    "href": "books.html",
    "title": "2  Books",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "3  Github Repos",
    "section": "",
    "text": "Tutorials on implementing a few sequence-to-sequence (seq2seq) models with PyTorch and TorchText\n\n\nThis repo contains tutorials covering understanding and implementing sequence-to-sequence (seq2seq) models using PyTorch 1.8, torchtext 0.9 and spaCy 3.0, using Python 3.8.\n\n\nTutorials on implementing a few sequence-to-sequence (seq2seq) models with PyTorch and TorchText\n\n\nThis repo contains tutorials covering how to do sentiment analysis using PyTorch 1.8 and torchtext 0.9 using Python 3.7.\n\n\nA Tour of PyTorch Optimizers\n\n\nIn this repo implement different gradient descent optimization algorithms by describing how they work and then implementing them in PyTorch (using version 1.10)."
  },
  {
    "objectID": "websites.html",
    "href": "websites.html",
    "title": "4  Websites",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "courses.html",
    "href": "courses.html",
    "title": "5  Courses",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "thesis.html",
    "href": "thesis.html",
    "title": "Thesis",
    "section": "",
    "text": "I commit to writting thesis daily."
  },
  {
    "objectID": "july04.html",
    "href": "july04.html",
    "title": "6  July 03,2022",
    "section": "",
    "text": "Structure of the PhD thesis to set the boll rolling\nSearch and collect materials that will help me to write the PhD thesis such as books and advices.\n\n\n6.0.1 Books for PhD Advice\n\nAuthoring a PhD Thesis: How to Plan, Draft, Write and Finish a Doctoral Dissertation 3rd Edition\nWriting Your Dissertation in Fifteen Minutes a Day: A Guide to Starting, Revising, and Finishing Your Doctoral Thesis\nThe Literature Review: Six Steps to Success Third Edition\nThe Craft of Research, Fourth Edition (Chicago Guides to Writing, Editing, and Publishing) Fourth Edition\n\n\nAs a PhD student, I had written dozens and dozens of research papers before reading this book. I wish now that I could redo them. The information presented in this book is clear and thorough. Even on my first skim of the book I have learned valuable skills that will improve my writing!! I only wish my undergrad professors had forced me to read this book previously!!\n\n\nIt’s still the best, esp. for new or returning graduate students, or for new faculty who teach grad classes or work in a research lab. It’s very clear without dumbing down the information, and does an excellent job of putting research questions in context. I still refer my grad students to the first chapters, esp. because the author takes the reader by the hand through examples of how to construct a decent research question, from scope to validity. Hard to beat.\n\n\nMy university students adore this book. They all wish they were assigned it in their first year of college rather than their fourth year (when they have me).\n\nHow to Write a Lot: A Practical Guide to Productive Academic Writing (Paperback)\nOn Writing, by Stephen King\nStrunk and Whites’ The Elements of Style\n\n\n\n\n\n6.0.2 Blog for PhD Advice\nCollections of Advise I have collected from multiple sources\n\nAs a PhD Examiner … My Top 25 Tips for PhD students\nFind good and best PhD thesis related to your field of study. You can find PhD Thesis on PhDThesis.org. Read through the thesis see how the thesis are structured. From there you can make your own structure too.\nJust Start Writing: No better time than now. Just start writting.\nMake a Schedule : Try to make schedule for each chapter and work toward completing it. Also, determine how many pages the chapter may take\nWrite the Introductions Last: Skip introduction since it will change after completing the chapters.\nMove Around : Dont stick on one chapter, if you are stuck, move to another chapter or section\nGet Feedback Early : Give supervisor draft for each chapter and get feedback early. Dont wait until the end to get feedback for the complete thesis. Give your supervisor enough time to read your thesis. Believe me they are busy, so agree a timescale with them.\nWhen you write a section leave it for a couple of days, then come back and edit it. This will help you to see mistakes more easily, with fresh eyes. You can repeat this process several times until you can’t find any more mistakes. Then, it’s time to give your thesis to somebody else to proofread.\nStart the document in style. Formatting the document from the start will make it easier at editing time1.\n\n\nReferences: Read your references one more time. Sometimes the reference management software makes mistakes.\nIf there’s research or analysis still to do, prioritize this over writing\nPreparation : Get rid of distractions (chats, emails, etc.).2\n\n\nTargets and consistency : Set a target and be consistent to that target (e.g., number of words to write). Dont be disappointed if you miss the target. “Set your target as something you know you can achieve daily, then beat it. Don’t set it as high as you can possibly imagine. I had a daily minimum target of 500 words, which I knew I could meet even on the least productive days. This meant that because I smashed the target most days, I finished every day feeling good about my progress, which in turn meant I started the next day feeling confident”3\nRoutine : Leave something easy that you will start next day at the end of each day. Close your computer browsers and clean your desk. This makes it easy for you to pick up next day.4\n\n\n10 tips for writing a PhD thesis\n\n\n\n6.0.3 Video for PhD Advice\n\n\n\n\n\n\nSailing Through Your PhD Thesis: Writing Tips↩︎\nHow I wrote a PhD thesis in 3 months↩︎\nHow I wrote a PhD thesis in 3 months↩︎\nHow I wrote a PhD thesis in 3 months↩︎"
  },
  {
    "objectID": "july05.html",
    "href": "july05.html",
    "title": "7  Programs",
    "section": "",
    "text": "In this chapter, you will build a real, working slot machine that you can play by running an R function. When you’re finished, you’ll be able to play it like this:\nThe play function will need to do two things. First, it will need to randomly generate three symbols; and, second, it will need to calculate a prize based on those symbols.\nThe first step is easy to simulate. You can randomly generate three symbols with the sample function—just like you randomly “rolled” two dice in Project 1: Weighted Dice. The following function generates three symbols from a group of common slot machine symbols: diamonds (DD), sevens (7), triple bars (BBB), double bars (BB), single bars (B), cherries (C), and zeroes (0). The symbols are selected randomly, and each symbol appears with a different probability:\nYou can use get_symbols to generate the symbols used in your slot machine:\nget_symbols uses the probabilities observed in a group of video lottery terminals from Manitoba, Canada. These slot machines became briefly controversial in the 1990s, when a reporter decided to test their payout rate. The machines appeared to pay out only 40 cents on the dollar, even though the manufacturer claimed they would pay out 92 cents on the dollar. The original data collected on the machines and a description of the controversy is available online in a journal article by W. John Braun. The controversy died down when additional testing showed that the manufacturer was correct.\nThe Manitoba slot machines use the complicated payout scheme shown in Table 7.1. A player will win a prize if he gets:\nOtherwise, the player receives no prize.\nThe monetary value of the prize is determined by the exact combination of symbols and is further modified by the presence of diamonds. Diamonds are treated like “wild cards,” which means they can be considered any other symbol if it would increase a player’s prize. For example, a player who rolls 7 7 DD would earn a prize for getting three sevens. There is one exception to this rule, however: a diamond cannot be considered a cherry unless the player also gets one real cherry. This prevents a dud roll like, 0 DD 0 from being scored as 0 C 0.\nDiamonds are also special in another way. Every diamond that appears in a combination doubles the amount of the final prize. So 7 7 DD would actually be scored higher than 7 7 7. Three sevens would earn you $80, but two sevens and a diamond would earn you $160. One seven and two diamonds would be even better, resulting in a prize that has been doubled twice, or $320. A jackpot occurs when a player rolls DD DD DD. Then a player earns $100 doubled three times, which is $800.\nTo create your play function, you will need to write a program that can take the output of get_symbols and calculate the correct prize based on Table 7.1.\nIn R, programs are saved either as R scripts or as functions. We’ll save your program as a function named score. When you are finished, you will be able to use score to calculate a prize like this:\nAfter that it will be easy to create the full slot machine, like this:\nYou may notice that play calls a new function, print. This will help play display the three slot machine symbols, since they do not get returned by the last line of the function. The print command prints its output to the console window – even if R calls it from within a function.\nIn Project 1: Weighted Dice, I encouraged you to write all of your R code in an R script, a text file where you can compose and save code. That advice will become very important as you work through this chapter. Remember that you can open an R script in RStudio by going to the menu bar and clicking on File > New File > R Script."
  },
  {
    "objectID": "july05.html#strategy",
    "href": "july05.html#strategy",
    "title": "7  Programs",
    "section": "7.1 Strategy",
    "text": "7.1 Strategy\nScoring slot-machine results is a complex task that will require a complex algorithm. You can make this, and other coding tasks, easier by using a simple strategy:\n\nBreak complex tasks into simple subtasks.\nUse concrete examples.\nDescribe your solutions in English, then convert them to R.\n\nLet’s start by looking at how you can divide a program into subtasks that are simple to work with.\nA program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward.\nYou can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function.\nR programs contain two types of subtasks: sequential steps and parallel cases.\n\n7.1.1 Sequential Steps\nOne way to subdivide a program is into a series of sequential steps. The play function takes the approach, shown in Figure 7.1. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3):\nplay <- function() {\n\n  # step 1: generate symbols\n  symbols <- get_symbols()\n\n  # step 2: display the symbols\n  print(symbols)\n\n  # step 3: score the symbols\n  score(symbols)\n}\nTo have R execute steps in sequence, place the steps one after another in an R script or function body.\n\n\n\nFigure 7.1: The play function uses a series of steps.\n\n\n\n\n7.1.2 Parallel Cases\nAnother way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time.\nFor example, score will need to calculate the prize one way if symbols contains three of a kind (In that case, score will need to match the common symbol to a prize). score will need to calculate the prize a second way if the symbols are all bars (In that case, score can just assign a prize of $5). And, finally, score will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, score must count the number of cherries present). score will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols.\nDiamonds complicate all of this because diamonds can be treated as wild cards. Let’s ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. score can double the prize as necessary after it runs one of the following algorithms, as shown in Figure 7.2.\nAdding the score cases to the play steps reveals a strategy for the complete slot machine program, as shown in Figure 7.3.\nWe’ve already solved the first few steps in this strategy. Our program can get three slot machine symbols with the get_symbols function. Then it can display the symbols with the print function. Now let’s examine how the program can handle the parallel score cases.\n\n\n\nFigure 7.2: The score function must distinguish between parallel cases.\n\n\n\n\n\nFigure 7.3: The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel."
  },
  {
    "objectID": "july05.html#if-statements",
    "href": "july05.html#if-statements",
    "title": "7  Programs",
    "section": "7.2 if Statements",
    "text": "7.2 if Statements\nLinking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an if statement.\nAn if statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say:\nif (this) {\n  that\n}\nThe this object should be a logical test or an R expression that evaluates to a single TRUE or FALSE. If this evaluates to TRUE, R will run all of the code that appears between the braces that follow the if statement (i.e., between the { and } symbols). If this evaluates to FALSE, R will skip the code between the braces without running it.\nFor example, you could write an if statement that ensures some object, num, is positive:\nif (num < 0) {\n  num <- num * -1\n}\nIf num < 0 is TRUE, R will multiply num by negative one, which will make num positive:\nnum <- -2\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 2\nIf num < 0 is FALSE, R will do nothing and num will remain as it is—positive (or zero):\nnum <- 4\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 4\nThe condition of an if statement must evaluate to a single TRUE or FALSE. If the condition creates a vector of TRUEs and FALSEs (which is easier to make than you may think), your if statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single TRUE or FALSE with the functions any and all.\nYou don’t have to limit your if statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that num is positive. The additional lines print some informative statements if num begins as a negative number. R will skip the entire code block—print statements and all—if num begins as a positive number:\nnum <- -1\n\nif (num < 0) {\n  print(\"num is negative.\")\n  print(\"Don't worry, I'll fix it.\")\n  num <- num * -1\n  print(\"Now num is positive.\")\n}\n## \"num is negative.\"\n## \"Don't worry, I'll fix it.\"\n## \"Now num is positive.\"\n\nnum\n## 1\nTry the following quizzes to develop your understanding of if statements.\n\n\n\n\n\n\nExercise: Quiz A\n\n\n\nWhat will this return?\nx <- 1\nif (3 == 3) {\n  x <- 2\n}\nx\n\n\nThe code will return the number 2. x begins as 1, and then R encounters the if statement. Since the condition evaluates to TRUE, R will run x <- 2, changing the value of x.\n\n\n\n\n\n\nExercise: Quiz B\n\n\n\nWhat will this return?\n```r\nx <- 1\nif (TRUE) {\n  x <- 2\n}\nx\n\n\nThis code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already TRUE. R doesn’t even need to evaluate it. As a result, the code inside the if statement will be run, and x will be set to 2.\n\n\n\n\n\n\nExercise: Quiz C\n\n\n\nWhat will this return?\nx <- 1\nif (x == 1) {\n  x <- 2\n  if (x == 1) {\n    x <- 3\n  }\n}\nx\n\n\nOnce again, the code will return the number 2. x starts out as 1, and the condition of the first if statement will evaluate to TRUE, which causes R to run the code in the body of the if statement. First, R sets x equal to 2, then R evaluates the second if statement, which is in the body of the first. This time x == 1 will evaluate to FALSE because x now equals 2. As a result, R ignores x <- 3 and exits both if statements."
  },
  {
    "objectID": "july05.html#else-statements",
    "href": "july05.html#else-statements",
    "title": "7  Programs",
    "section": "7.3 else Statements",
    "text": "7.3 else Statements\nif statements tell R what to do when your condition is true, but you can also tell R what to do when the condition is false. else is a counterpart to if that extends an if statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” In R, you would say:\nif (this) {\n  Plan A\n} else {\n  Plan B\n}\nWhen this evaluates to TRUE, R will run the code in the first set of braces, but not the code in the second. When this evaluates to FALSE, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer.\nStart with a decimal:\na <- 3.14\nThen isolate the decimal component with trunc:\ndec <- a - trunc(a)\ndec\n## 0.14\n\n\n\n\n\n\nNote\n\n\n\ntrunc takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number).\n\n\n\n\n\n\n\n\nNote\n\n\n\na - trunc(a) is a convenient way to return the decimal part of a.\n\n\nThen use an if else tree to round the number (either up or down):\nif (dec >= 0.5) {\n  a <- trunc(a) + 1\n} else {\n  a <- trunc(a)\n}\n\na\n## 3\nIf your situation has more than two mutually exclusive cases, you can string multiple if and else statements together by adding a new if statement immediately after else. For example:\na <- 1\nb <- 1\n\nif (a > b) {\n  print(\"A wins!\")\n} else if (a < b) {\n  print(\"B wins!\")\n} else {\n  print(\"Tie.\")\n}\n## \"Tie.\"\nR will work through the if conditions until one evaluates to TRUE, then R will ignore any remaining if and else clauses in the tree. If no conditions evaluate to TRUE, R will run the final else statement.\nIf two if statements describe mutually exclusive events, it is better to join the if statements with an else if than to list them separately. This lets R ignore the second if statement whenever the first returns a TRUE, which saves work.\nYou can use if and else to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final score function. Compare it to the flow chart for score in Figure 7.2:\nif ( # Case 1: all the same <1>) {\n  prize <- # look up the prize <3>\n} else if ( # Case 2: all bars <2> ) {\n  prize <- # assign $5 <4>\n} else {\n  # count cherries <5>\n  prize <- # calculate a prize <7>\n}\n\n# count diamonds <6>\n# double the prize if necessary <8>\nOur skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we’ve reduced the program to eight simple subtasks:\n<1> - Test whether the symbols are three of a kind.\n<2> - Test whether the symbols are all bars.\n<3> - Look up the prize for three of a kind based on the common symbol.\n<4> - Assign a prize of $5.\n<5> - Count the number of cherries.\n<6> - Count the number of diamonds.\n<7> - Calculate a prize based on the number of cherries.\n<8> - Adjust the prize for diamonds.\nIf you like, you can reorganize your flow chart around these tasks, as in Figure 7.4. The chart will describe the same strategy, but in a more precise way. I’ll use a diamond shape to symbolize an if else decision.\n\n\n\nFigure 7.4: score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.\n\n\nNow we can work through the subtasks one at a time, adding R code to the if tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R.\nThe first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask?\nYou know that the final score function will look something like this:\nscore <- function(symbols) {\n\n  # calculate a prize\n\n  prize\n}\nIts argument, symbols, will be the output of get_symbols, a vector that contains three character strings. You could start writing score as I have written it, by defining an object named score and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until all of those parts are written (and themselves work correctly). This means you would have to write the entire score function before you could test any of the subtasks. If score doesn’t work—which is very likely—you will not know which subtask needs fixed.\nYou can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on. For example, you know that score will need to work on a vector named symbols that contains three character strings. If you make a real vector named symbols, you can run the code for many of your subtasks on the vector as you go:\nsymbols <- c(\"7\", \"7\", \"7\")\nIf a piece of code does not work on symbols, you will know that you need to fix it before you move on. You can change the value of symbols from subtask to subtask to ensure that your code works in every situation:\nsymbols <- c(\"B\", \"BB\", \"BBB\")\nsymbols <- c(\"C\", \"DD\", \"0\")\nOnly combine your subtasks into a score function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work.\nAfter you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code.\nOur first subtask asks us to “test whether the symbols are three of a kind.” This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely:\nA vector named symbols will contain three of the same symbol if the first element of symbols is equal to the second element of symbols and the second element of symbols is equal to the third element of symbols.\n\n\n\n\n\n\nExercise: Write a Test\n\n\n\nTurn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from R Notation. The test should work with the vector symbols and return a TRUE if and only if each element in symbols is the same. Be sure to test your code on symbols.\n\n\nHere are a couple of ways to test that symbols contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you’ve created a vector named symbols:\nsymbols\n##  \"7\" \"7\" \"7\"\n\nsymbols[1] == symbols[2] & symbols[2] == symbols[3]\n## TRUE\n\nsymbols[1] == symbols[2] & symbols[1] == symbols[3]\n## TRUE\n\nall(symbols == symbols[1])\n## TRUE\nAs your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is:\nlength(unique(symbols) == 1)\nThe unique function returns every unique term that appears in a vector. If your symbols vector contains three of a kind (i.e., one unique term that appears three times), then unique(symbols) will return a vector of length 1.\nNow that you have a working test, you can add it to your slot-machine script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n\nif (same) {\n  prize <- # look up the prize\n} else if ( # Case 2: all bars ) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n\n\n\n\n\n\nNote\n\n\n\n&& and || behave like & and | but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if symbols[1] does not equal symbols[2] in the next expression, && will not evaluate symbols[2] == symbols[3]; it can immediately return a FALSE for the whole expression (because FALSE & TRUE and FALSE & FALSE both evaluate to FALSE). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. && and || are not vectorized, which means they can only handle a single logical test on each side of the operator.\n\n\nThe second prize case occurs when all the symbols are a type of bar, for example, B, BB, and BBB. Let’s begin by creating a concrete example to work with:\nsymbols <- c(\"B\", \"BBB\", \"BB\")\n\n\n\n\n\n\nExercise: Test for All Bars\n\n\n\nUse R’s logical and Boolean operators to write a test that will determine whether a vector named symbols contains only symbols that are a type of bar. Check whether your test works with our example symbols vector. Remember to describe how the test should work in English, and then convert the solution to R.\n\n\nAs with many things in R, there are multiple ways to test whether symbols contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this:\n(symbols[1] == \"B\" | symbols[1] == \"BB\" | symbols[1] == \"BBB\") &\n  (symbols[2] == \"B\" | symbols[2] == \"BB\" | symbols[2] == \"BBB\") &\n  (symbols[3] == \"B\" | symbols[3] == \"BB\" | symbols[3] == \"BBB\")\n## TRUE\nHowever, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple | operators with a single %in%. Also, you can check that a test is true for each element in a vector with all. These two changes shorten the preceding code to:\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nLet’s add this code to our script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  prize <- # look up the prize\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nYou may have noticed that I split this test up into two steps, bars and all(bars). That’s just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do.\nYou also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind:\nsymbols <- c(\"B\", \"B\", \"B\")\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nThat won’t be a problem, however, because we’ve connected our cases with else if in the if tree. As soon as R comes to a case that evaluates to TRUE, it will skip over the rest of the tree. Think of it this way: each else tells R to only run the code that follows it if none of the previous conditions have been met. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3).\nOur next subtask is to assign a prize for symbols. When the symbols vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three DDs, the prize will be $100; if there are three 7s, the prize will be $80; and so on.\nThis suggests another if tree. You could assign a prize with some code like this:\nif (same) {\n  symbol <- symbols[1]\n  if (symbol == \"DD\") {\n    prize <- 800\n  } else if (symbol == \"7\") {\n    prize <- 80\n  } else if (symbol == \"BBB\") {\n    prize <- 40\n  } else if (symbol == \"BB\") {\n    prize <- 5\n  } else if (symbol == \"B\") {\n    prize <- 10\n  } else if (symbol == \"C\") {\n    prize <- 10\n  } else if (symbol == \"0\") {\n    prize <- 0\n  }\n}\nWhile this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method."
  },
  {
    "objectID": "july05.html#lookup-tables",
    "href": "july05.html#lookup-tables",
    "title": "7  Programs",
    "section": "7.4 Lookup Tables",
    "text": "7.4 Lookup Tables\nVery often in R, the simplest way to do something will involve subsetting. How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements:\npayouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n  \"B\" = 10, \"C\" = 10, \"0\" = 0)\npayouts\n##  DD   7 BBB  BB   B   C   0 \n## 100  80  40  25  10  10   0 \nNow you can extract the correct prize for any symbol by subsetting the vector with the symbol’s name:\npayouts[\"DD\"]\n##  DD \n## 100 \n\npayouts[\"B\"]\n##  B\n## 10\nIf you want to leave behind the symbol’s name when subsetting, you can run the unname function on the output:\nunname(payouts[\"DD\"])\n## 100 \nunname returns a copy of an object with the names attribute removed.\npayouts is a type of lookup table, an R object that you can use to look up values. Subsetting payouts provides a simple way to find the prize for a symbol. It doesn’t take many lines of code, and it does the same amount of work whether your symbol is DD or 0. You can create lookup tables in R by creating named objects that can be subsetted in clever ways.\nSadly, our method is not quite automatic; we need to tell R which symbol to look up in payouts. Or do we? What would happen if you subsetted payouts by symbols[1]? Give it a try:\nsymbols <- c(\"7\", \"7\", \"7\")\nsymbols[1]\n## \"7\"\n\npayouts[symbols[1]]\n##  7 \n## 80 \n\nsymbols <- c(\"C\", \"C\", \"C\")\npayouts[symbols[1]]\n##  C \n## 10 \nYou don’t need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in symbols. You can find this symbol with symbols[1], symbols[2], or symbols[3], because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when symbols contains three of a kind. Let’s add it to our code and then look at Case 2:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nCase 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nNow we can work on the last case. Here, you’ll need to know how many cherries are in symbols before you can calculate a prize.\n\n\n\n\n\n\nExercise: Find C’s\n\n\n\nHow can you tell which elements of a vector named symbols are a C? Devise a test and try it out.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow might you count the number of Cs in a vector named symbols? Remember R’s coercion rules.\n\n\nAs always, let’s work with a real example:\nsymbols <- c(\"C\", \"DD\", \"C\")\nOne way to test for cherries would be to check which, if any, of the symbols are a C:\nsymbols == \"C\"\n## TRUE FALSE  TRUE\nIt’d be even more useful to count how many of the symbols are cherries. You can do this with sum, which expects numeric input, not logical. Knowing this, R will coerce the TRUEs and FALSEs to 1s and 0s before doing the summation. As a result, sum will return the number of TRUEs, which is also the number of cherries:\nsum(symbols == \"C\")\n## 2\nYou can use the same method to count the number of diamonds in symbols:\nsum(symbols == \"DD\")\n## 1\nLet’s add both of these subtasks to the program skeleton:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- # calculate a prize\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\nSince Case 3 appears further down the if tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine’s payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don’t need to worry about three cherries because that outcome is already covered in Case 1.\nAs in Case 1, you could write an if tree that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution:\nif (cherries == 2) {\n  prize <- 5\n} else if (cherries == 1) {\n  prize <- 2\n} else {}\n  prize <- 0\n}\nAgain, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution.\nWe know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table:\nc(0, 2, 5)\nNow, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize’s aren’t identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in cherries. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, c(0, 2, 5)[1].\ncherries isn’t exactly suited for integer subsetting because it could contain a zero, but that’s easy to fix. We can subset with cherries + 1. Now when cherries equals zero, we have:\ncherries + 1\n## 1\n\nc(0, 2, 5)[cherries + 1]\n## 0\nWhen cherries equals one, we have:\ncherries + 1\n## 2\n\nc(0, 2, 5)[cherries + 1]\n## 2\nAnd when cherries equals two, we have:\ncherries + 1\n## 3\n\nc(0, 2, 5)[cherries + 1]\n## 5\nExamine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\n\n\n\n\n\n\nLookup Tables Versus if Trees\n\n\n\nThis is the second time we’ve created a lookup table to avoid writing an if tree. Why is this technique helpful and why does it keep appearing? Many if trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, if trees are not appropriate everywhere.\nif trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the if tree, which can create unnecessary work. Second, as you’ll see in Speed, it can be difficult to use if trees in vectorized code, a style of code that takes advantage of R’s programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks.\nYou won’t be able to replace every if tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with if trees. As a general rule, use an if tree if each branch of the tree runs different code. Use a lookup table if each branch of the tree only assigns a different value.\nTo convert an if tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the if tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting.\n\n\nThe final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize. For example, if no diamonds are present, the prize will be:\nprize * 1      # 1 = 2 ^ 0\nIf one diamond is present, it will be:\nprize * 2      # 2 = 2 ^ 1\nIf two diamonds are present, it will be:\nprize * 4      # 4 = 2 ^ 2\nAnd if three diamonds are present, it will be:\nprize * 8      # 8 = 2 ^ 3\nCan you think of an easy way to handle this? How about something similar to these examples?\n\n\n\n\n\n\nExercise: Adjust for Diamonds\n\n\n\nWrite a method for adjusting prize based on diamonds. Describe a solution in English first, and then write your code.\n\n\nHere is a concise solution inspired by the previous pattern. The adjusted prize will equal:\nprize * 2 ^ diamonds\nwhich gives us our final score script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds"
  },
  {
    "objectID": "july05.html#code-comments",
    "href": "july05.html#code-comments",
    "title": "7  Programs",
    "section": "7.5 Code Comments",
    "text": "7.5 Code Comments\nYou now have a working score script that you can save to a function. Before you save your script, though, consider adding comments to your code with a #. Comments can make your code easier to understand by explaining why the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the score code:\n# identify case\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\n# get prize\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\n# adjust for diamonds\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds\nNow that each part of your code works, you can wrap it into a function with the methods you learned in Writing Your Own Functions. Either use RStudio’s Extract Function option in the menu bar under Code, or use the function function. Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like symbols, will become the arguments of your function. Run the following code to start using the score function:\nscore <- function (symbols) {\n  # identify case\n  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n  bars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # get prize\n  if (same) {\n    payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    prize <- unname(payouts[symbols[1]])\n  } else if (all(bars)) {\n    prize <- 5\n  } else {\n    cherries <- sum(symbols == \"C\")\n    prize <- c(0, 2, 5)[cherries + 1]\n  }\n  \n  # adjust for diamonds\n  diamonds <- sum(symbols == \"DD\")\n  prize * 2 ^ diamonds\n}\nOnce you have defined the score function, the play function will work as well:\nplay <- function() {\n  symbols <- get_symbols()\n  print(symbols)\n  score(symbols)\n}\nNow it is easy to play the slot machine:\nplay()\n## \"0\"  \"BB\" \"B\" \n## 0\n\nplay()\n## \"DD\"  \"0\" \"B\"  \n## 0\n\nplay()\n## \"BB\" \"BB\" \"B\" \n## 25"
  },
  {
    "objectID": "july05.html#summary",
    "href": "july05.html#summary",
    "title": "7  Programs",
    "section": "7.6 Summary",
    "text": "7.6 Summary\nAn R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don’t be fooled: you can create complicated results with the right combination of simple steps (and cases).\nAs a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse.\nR provides tools that can help you do this. You can manage cases with if and else statements. You can create a lookup table with objects and subsetting. You can add code comments with #. And you can save your programs as a function with function.\nThings often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time. However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R’s built in debugging tools, described in Debugging R Code.\nThe next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In S3, you will learn how to use R’s S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class."
  },
  {
    "objectID": "abstract.html",
    "href": "abstract.html",
    "title": "8  R Objects",
    "section": "",
    "text": "Curiously, it turns out that the classifications that we get if we use linear regression to predict a binary response will be the same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4\nValues of the odds close to 0 and ∞ indicate very low and very high probabilities of default, respectively.\nAsume p =1—that is, we have one parameter for each feature."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "9  Introduction",
    "section": "",
    "text": "However, despite their usefulness, xx are far from being a silver bullet\nHeere are a few challenges associated with them that we will explore\nIssue with Transformer and other deep learning models is opecity: As with other deep learning models, transformers are to a large extent opaque. It is hard or impossible to unravel “why” a model made a certain prediction. This is an especially hard challenge when these models are deployed to make critical decisions."
  }
]