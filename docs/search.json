[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Big book of my PhD",
    "section": "",
    "text": "This is the website for “Big book for my PhD” by Shamsuddeen Muhammad. This book contains resources, tips, recommdations based on my experience as a PhD student. I decided to put everything in this book and make it available to the public so that someone can read and benfit the experience or the resources.\n\n\n\n\n\n\nYou can visit my website and blog"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Big book of my PhD",
    "section": "License",
    "text": "License\nThis website is (and will always be) free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "This book will teach you how to program in R. You’ll go from loading data to writing your own functions (which will outperform the functions of other R users). But this is not a typical introduction to R. I want to help you become a data scientist, as well as a computer scientist, so this book will focus on the programming skills that are most related to data science.\nThe chapters in the book are arranged according to three practical projects–given that they’re fairly substantial projects, they span multiple chapters. I chose these projects for two reasons. First, they cover the breadth of the R language. You will learn how to load data, assemble and disassemble data objects, navigate R’s environment system, write your own functions, and use all of R’s programming tools, such as if else statements, for loops, S3 classes, R’s package system, and R’s debugging tools. The projects will also teach you how to write vectorized R code, a style of lightning-fast code that takes advantage of all of the things R does best.\nBut, more importantly, the projects will teach you how to solve the logistical problems of data science—and there are many logistical problems. When you work with data, you will need to store, retrieve, and manipulate large sets of values without introducing errors. As you work through the book, I will teach you not just how to program with R, but how to use the programming skills to support your work as a data scientist.\nNot every programmer needs to be a data scientist, so not every programmer will find this book useful. You will find this book helpful if you’re in one of the following categories:\nOne of the biggest surprises in this book is that I do not cover traditional applications of R, such as models and graphs; instead, I treat R purely as a programming language. Why this narrow focus? R is designed to be a tool that helps scientists analyze data. It has many excellent functions that make plots and fit models to data. As a result, many statisticians learn to use R as if it were a piece of software—they learn which functions do what they want, and they ignore the rest.\nThis is an understandable approach to learning R. Visualizing and modeling data are complicated skills that require a scientist’s full attention. It takes expertise, judgement, and focus to extract reliable insights from a data set. I would not recommend that any data scientist distract herself with computer programming until she feels comfortable with the basic theory and practice of her craft. If you would like to learn the craft of data science, I recommend the book R for Data Science, my companion volume to this book, co-written with Hadley Wickham.\nHowever, learning to program should be on every data scientist’s to-do list. Knowing how to program will make you a more flexible analyst and augment your mastery of data science in every way. My favorite metaphor for describing this was introduced by Greg Snow on the R help mailing list in May 2006. Using functions in R is like riding a bus. Writing functions in R is like driving a car.\nGreg compares R to SPSS, but he assumes that you use the full powers of R; in other words, that you learn how to program in R. If you only use functions that preexist in R, you are using R like SPSS: it is a bus that can only take you to certain places.\nThis flexibility matters to data scientists. The exact details of a method or simulation will change from problem to problem. If you cannot build a method tailored to your situation, you may find yourself tempted to make unrealistic assumptions just so you can use an ill-suited method that already exists.\nThis book will help you make the leap from bus to car. I have written it for beginning programmers. I do not talk about the theory of computer science—there are no discussions of big O() and little o() in these pages. Nor do I get into advanced details such as the workings of lazy evaluation. These things are interesting if you think of computer science at the theoretical level, but they are a distraction when you first learn to program.\nInstead, I teach you how to program in R with three concrete examples. These examples are short, easy to understand, and cover everything you need to know.\nI have taught this material many times in my job as Master Instructor at RStudio. As a teacher, I have found that students learn abstract concepts much faster when they are illustrated by concrete examples. The examples have a second advantage, as well: they provide immediate practice. Learning to program is like learning to speak another language—you progress faster when you practice. In fact, learning to program is learning to speak another language. You will get the best results if you follow along with the examples in the book and experiment whenever an idea strikes you.\nThe book is a companion to R for Data Science. In that book, Hadley Wickham and I explain how to use R to make plots, model data, and write reports. That book teaches these tasks as data-science skills, which require judgement and expertise—not as programming exercises, which they also are. This book will teach you how to program in R. It does not assume that you have mastered the data-science skills taught in R for Data Science (nor that you ever intend to). However, this skill set amplifies that one. And if you master both, you will be a powerful, computer-augmented data scientist, fit to command a high salary and influence scientific dialogue."
  },
  {
    "objectID": "preface.html#conventions-used-in-this-book",
    "href": "preface.html#conventions-used-in-this-book",
    "title": "Preface",
    "section": "Conventions Used in This Book",
    "text": "Conventions Used in This Book\nThe following typographical conventions are used in this book:\nItalic:: Indicates new terms, URLs, email addresses, filenames, and file extensions.\nConstant width:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.\nConstant width bold:: Shows commands or other text that should be typed literally by the user.\nConstant width italic:: Shows text that should be replaced with user-supplied values or by values determined by context.\nTo comment or ask technical questions about this book, please file an issue at github.com/rstudio-education/hopr."
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nMany excellent people have helped me write this book, from my two editors, Courtney Nash and Julie Steele, to the rest of the O’Reilly team, who designed, proofread, and indexed the book. Also, Greg Snow generously let me quote him in this preface. I offer them all my heartfelt thanks.\nI would also like to thank Hadley Wickham, who has shaped the way I think about and teach R. Many of the ideas in this book come from Statistics 405, a course that I helped Hadley teach when I was a PhD student at Rice University.\nFurther ideas came from the students and teachers of Introduction to Data Science with R, a workshop that I teach on behalf of RStudio. Thank you to all of you. I’d like to offer special thanks to my teaching assistants Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson, and Vivian Zhang.\nThank you also to JJ Allaire and the rest of my colleagues at RStudio who provide the RStudio IDE, a tool that makes it much easier to use, teach, and write about R.\nFinally, I would like to thank my wife, Kristin, for her support and understanding while I wrote this book."
  },
  {
    "objectID": "dice.html",
    "href": "dice.html",
    "title": "Project 1: Weighted Dice",
    "section": "",
    "text": "As a data scientist who knows how to program, you will improve your ability to:\n\nMemorize (store) entire data sets\nRecall data values on demand\nPerform complex calculations with large amounts of data\nDo repetitive tasks without becoming careless or bored\n\nComputers can do all of these things quickly and error free, which lets your mind do the things it does well: make decisions and assign meaning.\nSound exciting? Great! Let’s begin.\nWhen I was a college student, I sometimes daydreamed of going to Las Vegas. I thought that knowing statistics might help me win big. If that’s what led you to data science, you better sit down; I have some bad news. Even a statistician will lose money in a casino over the long run. This is because the odds for each game are always stacked in the casino’s favor. However, there is a loophole to this rule. You can make money–and reliably too. All you have to do is be the casino.\nBelieve it or not, R can help you do that. Over the course of the book, you will use R to build three virtual objects: a pair of dice that you can roll to generate random numbers, a deck of cards that you can shuffle and deal from, and a slot machine modeled after some real-life video lottery terminals. After that, you’ll just need to add some video graphics and a bank account (and maybe get a few government licenses), and you’ll be in business. I’ll leave those details to you.\nThese projects are lighthearted, but they are also deep. As you complete them, you will become an expert at the skills you need to work with data as a data scientist. You will learn how to store data in your computer’s memory, how to access data that is already there, and how to transform data values in memory when necessary. You will also learn how to write your own programs in R that you can use to analyze data and run simulations.\nIf simulating a slot machine (or dice, or cards) seems frivilous, think of it this way: playing a slot machine is a process. Once you can simulate it, you’ll be able to simulate other processes, such as bootstrap sampling, Markov chain Monte Carlo, and other data-analysis procedures. Plus, these projects provide concrete examples for learning all of the components of R programming: objects, data types, classes, notation, functions, environments, if trees, loops, and vectorization. This first project will make it easier to study these things by teaching you the basics of R.\nYour first mission is simple: assemble R code that will simulate rolling a pair of dice, like at a craps table. Once you have done that, we’ll weight the dice a bit in your favor, just to keep things interesting.\nIn this project, you will learn how to:\n\nUse the R and RStudio interfaces\nRun R commands\nCreate R objects\nWrite your own R functions and scripts\nLoad and use R packages\nGenerate random samples\nCreate quick plots\nGet help when you need it\n\nDon’t worry if it seems like we cover a lot of ground fast. This project is designed to give you a concise overview of the R language. You will return to many of the concepts we meet here in projects 2 and 3, where you will examine the concepts in depth.\nYou’ll need to have both R and RStudio installed on your computer before you can use them. Both are free and easy to download. See Chapter A for complete instructions. If you are ready to begin, open RStudio on your computer and read on."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "1  The Very Basics",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "basics.html#the-r-user-interface",
    "href": "basics.html#the-r-user-interface",
    "title": "1  The Very Basics",
    "section": "1.1 The R User Interface",
    "text": "1.1 The R User Interface\nBefore you can ask your computer to save some numbers, you’ll need to know how to talk to it. That’s where R and RStudio come in. RStudio gives you a way to talk to your computer. R gives you a language to speak in. To get started, open RStudio just as you would open any other application on your computer. When you do, a window should appear in your screen like the one shown in Figure 1.1.\n\n\n\nFigure 1.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File > Preferences in the menu bar.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you do not yet have R and RStudio installed on your computer–or do not know what I am talking about–visit Appendix A. The appendix will give you an overview of the two free tools and tell you how to download them.\n\n\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\n> 1 + 1\n[1] 2\n>\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\n> 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou may hear me speak of R in the third person. For example, I might say, “Tell R to do this” or “Tell R to do that”, but of course R can’t do anything; it is just a language. This way of speaking is shorthand for saying, “Tell your computer to do this by writing a command in the R language at the command line of your RStudio console.” Your computer, and not R, does the actual work.\nIs this shorthand confusing and slightly lazy to use? Yes. Do a lot of people use it? Everyone I know–probably because it is so convenient.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\n> 5 -\n+\n+ 1\n[1] 4\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\n> 3 % 5\nError: unexpected input in \"3 % 5\"\n>\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n## 6\n\n4 - 1   \n## 3\n\n6 / (4 - 1)   \n## 2\nDid you notice something different about this code? I’ve left out the >’s and [1]’s. This will make the code easier to copy and paste if you want to put it in your own console.\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\nFor the remainder of the book, I’ll use hashtags to display the output of R code. I’ll use a single hashtag to add my own comments and a double hashtag, ##, to display the results of code. I’ll avoid showing >s and [1]s unless I want you to look at them.\n\n\n\n\n\n\nImportant\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c. Note that it may also take R a long time to cancel the command.\n\n\n\n\n\n\n\n\nExercise: Magic with Numbers\n\n\n\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n\nThroughout the book, I’ll put exercises in chunks, like the one above. I’ll follow each exercise with a model answer, like the one below.\nYou could start with the number 10, and then do the following steps:\n10 + 2\n## 12\n\n12 * 3\n## 36\n\n36 - 6\n## 30\n\n30 / 3\n## 10"
  },
  {
    "objectID": "basics.html#objects",
    "href": "basics.html#objects",
    "title": "1  The Very Basics",
    "section": "1.2 Objects",
    "text": "1.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector, a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere in your computer’s memory. What you are looking at is basically the footprints of six numbers that existed briefly and then melted back into your computer’s RAM. If you want to use those numbers again, you’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\na <- 1\na\n## 1\n\na + 2\n## 3\n\n\n\n\n\n\nNote\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, <, followed by a minus sign, -, to save data into it. This combination looks like an arrow, <-. R will make an object, give it your name, and store in it whatever follows the arrow. So a <- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\ndie <- 1:6\n\ndie\n## 1 2 3 4 5 6\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 1.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\nFigure 1.2: The RStudio environment pane keeps track of the R objects you create.\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\n\nGood names\nNames that cause errors\n\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\nName <- 1\nname <- 0  \n  \nName + 1  \n## 2  \n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\nmy_number <- 1\nmy_number \n## 1\n\nmy_number <- 999\nmy_number\n## 999\nYou can see which object names you have already used with the function ls:\nls()\n## \"a\"         \"die\"       \"my_number\" \"name\"     \"Name\"     \nYou can also see which names you have used by examining RStudio’s environment pane.\nYou now have a virtual die that is stored in your computer’s memory. You can access it whenever you like by typing the word die. So what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\ndie - 1\n## 0 1 2 3 4 5\n\ndie / 2\n## 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n## 1  4  9 16 25 36\nIf you are a big fan of linear algebra (and who isn’t?), you may notice that R does not always follow the rules of matrix multiplication. Instead, R uses element-wise execution. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two, as shown in Figure 1.3.\n\n\n\nFigure 1.3: When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 1.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n1:2\n## 1 2\n\n1:4\n## 1 2 3 4\n\ndie\n## 1 2 3 4 5 6\n\ndie + 1:2\n## 2 4 4 6 6 8\n\ndie + 1:4\n## 2 4 6 8 6 8\nWarning message:\nIn die + 1:4 :\n  longer object length is not a multiple of shorter object length\n\n\n\nFigure 1.4: R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\nBut don’t think that R has given up on traditional matrix multiplication. You just have to ask for it when you want it. You can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\ndie %*% die\n## 91\n\ndie %o% die\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    2    3    4    5    6\n## [2,]    2    4    6    8   10   12\n## [3,]    3    6    9   12   15   18\n## [4,]    4    8   12   16   20   24\n## [5,]    5   10   15   20   25   30\n## [6,]    6   12   18   24   30   36\nYou can also do things like transpose a matrix with t and take its determinant with det.\nDon’t worry if you’re not familiar with these operations. They are easy to look up, and you won’t need them for this book.\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function."
  },
  {
    "objectID": "basics.html#functions",
    "href": "basics.html#functions",
    "title": "1  The Very Basics",
    "section": "1.3 Functions",
    "text": "1.3 Functions\nR comes with many functions that you can use to do sophisticated tasks like random sampling. For example, you can round a number with the round function, or calculate its factorial with the factorial function. Using a function is pretty simple. Just write the name of the function and then the data you want the function to operate on in parentheses:\nround(3.1415)\n## 3\n\nfactorial(3)\n## 6\nThe data that you pass into the function is called the function’s argument. The argument can be raw data, an R object, or even the results of another R function. In this last case, R will work from the innermost function to the outermost, as in Figure 1.5.\nmean(1:6)\n## 3.5\n\nmean(die)\n## 3.5\n\nround(mean(die))\n## 4\n\n\n\nFigure 1.5: When you link functions together, R will resolve them from the innermost operation to the outermost. Here R first looks up die, then calculates the mean of one through six, then rounds the mean.\n\n\nLucky for us, there is an R function that can help “roll” the die. You can simulate a roll of the die with R’s sample function. sample takes two arguments: a vector named x and a number named size. sample will return size elements from the vector:\nsample(x = 1:4, size = 2)\n## 3 2\nTo roll your die and get a number back, set x to die and sample one element from it. You’ll get a new (maybe different) number each time you roll it:\nsample(x = die, size = 1)\n## 2\n\nsample(x = die, size = 1)\n## 1\n\nsample(x = die, size = 1)\n## 6\nMany R functions take multiple arguments that help them do their job. You can give a function as many arguments as you like as long as you separate each argument with a comma.\nYou may have noticed that I set die and 1 equal to the names of the arguments in sample, x and size. Every argument in every R function has a name. You can specify which data should be assigned to which argument by setting a name equal to data, as in the preceding code. This becomes important as you begin to pass multiple arguments to the same function; names help you avoid passing the wrong data to the wrong argument. However, using names is optional. You will notice that R users do not often use the name of the first argument in a function. So you might see the previous code written as:\nsample(die, size = 1)\n## 2\nOften, the name of the first argument is not very descriptive, and it is usually obvious what the first piece of data refers to anyways.\nBut how do you know which argument names to use? If you try to use a name that a function does not expect, you will likely get an error:\nround(3.1415, corners = 2)\n## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)\nIf you’re not sure which names to use with a function, you can look up the function’s arguments with args. To do this, place the name of the function in the parentheses behind args. For example, you can see that the round function takes two arguments, one named x and one named digits:\nargs(round)\n## function (x, digits = 0) \n## NULL\nDid you notice that args shows that the digits argument of round is already set to 0? Frequently, an R function will take optional arguments like digits. These arguments are considered optional because they come with a default value. You can pass a new value to an optional argument if you want, and R will use the default value if you do not. For example, round will round your number to 0 digits past the decimal point by default. To override the default, supply your own value for digits:\nround(3.1415)\n## 3\n\nround(3.1415, digits = 2)\n## 3.14\nYou should write out the names of each argument after the first one or two when you call a function with multiple arguments. Why? First, this will help you and others understand your code. It is usually obvious which argument your first input refers to (and sometimes the second input as well). However, you’d need a large memory to remember the third and fourth arguments of every R function. Second, and more importantly, writing out argument names prevents errors.\nIf you do not write out the names of your arguments, R will match your values to the arguments in your function by order. For example, in the following code, the first value, die, will be matched to the first argument of sample, which is named x. The next value, 1, will be matched to the next argument, size:\nsample(die, 1)\n## 2\nAs you provide more arguments, it becomes more likely that your order and R’s order may not align. As a result, values may get passed to the wrong argument. Argument names prevent this. R will always match a value to its argument name, no matter where it appears in the order of arguments:\nsample(size = 1, x = die)\n## 2\n\n1.3.1 Sample with Replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n## 3 4\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n## 5 5\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n## 2 4\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice <- sample(die, size = 2, replace = TRUE)\ndice\n## 2 4\n\nsum(dice)\n## 6\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n## 2 4\n\ndice\n## 2 4\n\ndice\n## 2 4\nNope. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. This is a relief in a way. Once you save a set of results to an R object, those results do not change. Programming would be quite hard if the values of your objects changed each time you called them.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function."
  },
  {
    "objectID": "basics.html#sec-write-functions",
    "href": "basics.html#sec-write-functions",
    "title": "1  The Very Basics",
    "section": "1.4 Writing Your Own Functions",
    "text": "1.4 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\ndie <- 1:6\ndice <- sample(die, size = 2, replace = TRUE)\nsum(dice)\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n1.4.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\nmy_function <- function() {}\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\n\n\n\n\n\n\nNote\n\n\n\nNotice that I indented each line of code between the braces. This makes the code easier for you and me to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\nroll()\n## 9\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\nroll\n## function() {\n##   die <- 1:6\n##   dice <- sample(die, size = 2, replace = TRUE)\n##   sum(dice)\n## }\n\nroll()\n## 6\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice <- sample(die, size = 2, replace = TRUE)\ntwo <- 1 + 1\na <- sqrt(2)\nDo you notice the pattern? These lines of code do not return a value to the command line; they save a value to an object."
  },
  {
    "objectID": "basics.html#arguments",
    "href": "basics.html#arguments",
    "title": "1  The Very Basics",
    "section": "1.5 Arguments",
    "text": "1.5 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones, like this?\nroll2 <- function() {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\nroll2 <- function(bones) {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2. Dungeons and Dragons, here we come!\nRemember, we’re rolling pairs of dice:\nroll2(bones = 1:4)\n##  3\n\nroll2(bones = 1:6)\n## 10\n\nroll2(1:20)\n## 31\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\nroll2 <- function(bones = 1:6) {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\nroll2()\n## 9\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 1.6.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like. Project 3: Slot Machine will teach you much more about writing functions in R.\n\n\n\nFigure 1.6: Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later."
  },
  {
    "objectID": "basics.html#scripts",
    "href": "basics.html#scripts",
    "title": "1  The Very Basics",
    "section": "1.6 Scripts",
    "text": "1.6 Scripts\nWhat if you want to edit roll2 again? You could go back and retype each line of code in roll2, but it would be so much easier if you had a draft of the code to start from. You can create a draft of your code as you go by using an R script. An R script is just a plain text file that you save R code in. You can open an R script in RStudio by going to File > New File > R script in the menu bar. RStudio will then open a fresh script above your console pane, as shown in Figure 1.7.\nI strongly encourage you to write and edit all of your R code in a script before you run it in the console. Why? This habit creates a reproducible record of your work. When you’re finished for the day, you can save your script and then use it to rerun your entire analysis the next day. Scripts are also very handy for editing and proofreading your code, and they make a nice copy of your work to share with others. To save a script, click the scripts pane, and then go to File > Save As in the menu bar.\n\n\n\nFigure 1.7: When you open an R Script (File > New File > R Script in the menu bar), RStudio creates a fourth pane above the console where you can write and edit your code.\n\n\nRStudio comes with many built-in features that make it easy to work with scripts. First, you can automatically execute a line of code in a script by clicking the Run button, as shown in Figure 1.8.\nR will run whichever line of code your cursor is on. If you have a whole section highlighted, R will run the highlighted code. Alternatively, you can run the entire script by clicking the Source button. Don’t like clicking buttons? You can use Control + Return as a shortcut for the Run button. On Macs, that would be Command + Return.\n\n\n\nFigure 1.8: You can run a highlighted portion of code in your script if you click the Run button at the top of the scripts pane. You can run the entire script by clicking the Source button.\n\n\nIf you’re not convinced about scripts, you soon will be. It becomes a pain to write multi-line code in the console’s single-line command line. Let’s avoid that headache and open your first script now before we move to the next chapter.\n\n\n\n\n\n\nExtract function\n\n\n\nRStudio comes with a tool that can help you build functions. To use it, highlight the lines of code in your R script that you want to turn into a function. Then click Code > Extract Function in the menu bar. RStudio will ask you for a function name to use and then wrap your code in a function call. It will scan the code for undefined variables and use these as arguments.\nYou may want to double-check RStudio’s work. It assumes that your code is correct, so if it does something surprising, you may have a problem in your code."
  },
  {
    "objectID": "basics.html#summary",
    "href": "basics.html#summary",
    "title": "1  The Very Basics",
    "section": "1.7 Summary",
    "text": "1.7 Summary\nYou’ve covered a lot of ground already. You now have a virtual die stored in your computer’s memory, as well as your own R function that rolls a pair of dice. You’ve also begun speaking the R language.\nAs you’ve seen, R is a language that you can use to talk to your computer. You write commands in R and run them at the command line for your computer to read. Your computer will sometimes talk back–for example, when you commit an error–but it usually just does what you ask and then displays the result.\nThe two most important components of the R language are objects, which store data, and functions, which manipulate data. R also uses a host of operators like +, -, *, /, and <- to do basic tasks. As a data scientist, you will use R objects to store data in your computer’s memory, and you will use functions to automate tasks and do complicated calculations. We will examine objects in more depth later in Project 2: Playing Cards and dig further into functions in Project 3: Slot Machine. The vocabulary you have developed here will make each of those projects easier to understand. However, we’re not done with your dice yet.\nIn Packages and Help Pages, you’ll run some simulations on your dice and build your first graphs in R. You’ll also look at two of the most useful components of the R language: R packages, which are collections of functions writted by R’s talented community of developers, and R documentation, which is a collection of help pages built into R that explains every function and data set in the language."
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "2  Packages and Help Pages",
    "section": "",
    "text": "You now have a function that simulates rolling a pair of dice. Let’s make things a little more interesting by weighting the dice in your favor. The house always wins, right? Let’s make the dice roll high numbers slightly more often than it rolls low numbers.\nBefore we weight the dice, we should make sure that they are fair to begin with. Two tools will help you do this: repetition and visualization. By coincidence, these tools are also two of the most useful superpowers in the world of data science.\nWe will repeat our dice rolls with a function called replicate, and we will visualize our rolls with a function called qplot. qplot does not come with R when you download it; qplot comes in a standalone R package. Many of the most useful R tools come in R packages, so let’s take a moment to look at what R packages are and how you can use them.\nYou can make a histogram of x3 with qplot(x3, binwidth = 1). The histogram will look like a symmetric pyramid. The middle bar will have a height of 3 and will appear above [2, 3), but be sure to try it and see for yourself.\nYou can use a histogram to display visually how common different values of x are. Numbers covered by a tall bar are more common than numbers covered by a short bar.\nHow can you use a histogram to check the accuracy of your dice?\nWell, if you roll your dice many times and keep track of the results, you would expect some numbers to occur more than others. This is because there are more ways to get some numbers by adding two dice together than to get other numbers, as shown in Figure 2.3.\nIf you roll your dice many times and plot the results with qplot, the histogram will show you how often each sum appeared. The sums that occurred most often will have the highest bars. The histogram should look like the pattern in Figure Figure 2.3 if the dice are fairly weighted.\nThis is where replicate comes in. replicate provides an easy way to repeat an R command many times. To use it, first give replicate the number of times you wish to repeat an R command, and then give it the command you wish to repeat. replicate will run the command multiple times and store the results as a vector:\nA histogram of your first 10 rolls probably won’t look like the pattern shown in Figure 2.3. Why not? There is too much randomness involved. Remember that we use dice in real life because they are effective random number generators. Patterns of long run frequencies will only appear over the long run. So let’s simulate 10,000 dice rolls and plot the results. Don’t worry; qplot and replicate can handle it. The results appear in Figure 2.4:\nThe results suggest that the dice are fair. Over the long run, each number occurs in proportion to the number of combinations that generate it.\nNow how can you bias these results? The previous pattern occurs because each underlying combination of dice (e.g., (3,4)) occurs with the same frequency. If you could increase the probability that a 6 is rolled on either die, then any combination with a six in it will occur more often than any combination without a six in it. The combination (6, 6) would occur most of all. This won’t make the dice add up to 12 more often than they add up to seven, but it will skew the results toward the higher numbers.\nTo put it another way, the probability of rolling any single number on a fair die is 1/6. I’d like you to change the probability to 1/8 for each number below six, and then increase the probability of rolling a six to 3/8:\nYou can change the probabilities by adding a new argument to the sample function. I’m not going to tell you what the argument is; instead I’ll point you to the help page for the sample function. What’s that? R functions come with help pages? Yes they do, so let’s learn how to read one."
  },
  {
    "objectID": "packages.html#packages",
    "href": "packages.html#packages",
    "title": "2  Packages and Help Pages",
    "section": "2.1 Packages",
    "text": "2.1 Packages\nYou’re not the only person writing your own functions with R. Many professors, programmers, and statisticians use R to design tools that can help people analyze data. They then make these tools free for anyone to use. To use these tools, you just have to download them. They come as preassembled collections of functions and objects called packages. Appendix B: R Packages contains detailed instructions for downloading and updating R packages, but we’ll look at the basics here.\nWe’re going to use the qplot function to make some quick plots. qplot comes in the ggplot2 package, a popular package for making graphs. Before you can use qplot, or anything else in the ggplot2 package, you need to download and install it.\n\n2.1.1 install.packages\nEach R package is hosted at http://cran.r-project.org, the same website that hosts R. However, you don’t need to visit the website to download an R package; you can download packages straight from R’s command line. Here’s how:\n\nOpen RStudio.\nMake sure you are connected to the Internet.\nRun install.packages(\"ggplot2\") at the command line.\n\nThat’s it. R will have your computer visit the website, download ggplot2, and install the package in your hard drive right where R wants to find it. You now have the ggplot2 package. If you would like to install another package, replace ggplot2 with your package name in the code.\n\n\n2.1.2 library\nInstalling a package doesn’t place its functions at your fingertips just yet: it simply places them in your hard drive. To use an R package, you next have to load it in your R session with the command library(\"ggplot2\"). If you would like to load a different package, replace ggplot2 with your package name in the code.\nTo see what this does, try an experiment. First, ask R to show you the qplot function. R won’t be able to find qplot because qplot lives in the ggplot2 package, which you haven’t loaded:\nqplot\n## Error: object 'qplot' not found\nNow load the ggplot2 package:\nlibrary(\"ggplot2\")\nIf you installed the package with install.packages as instructed, everything should go fine. Don’t worry if you don’t see any results or messages. No news is fine news when loading a package. Don’t worry if you do see a message either; ggplot2 sometimes displays helpful start up messages. As long as you do not see anything that says “Error,” you are doing fine.\nNow if you ask to see qplot, R will show you quite a bit of code (qplot is a long function):\nqplot\n## (quite a bit of code)\nAppendix B: R Packages contains many more details about acquiring and using packages. I recommend that you read it if you are unfamiliar with R’s package system. The main thing to remember is that you only need to install a package once, but you need to load it with library each time you wish to use it in a new R session. R will unload all of its packages each time you close RStudio.\nNow that you’ve loaded qplot, let’s take it for a spin. qplot makes “quick plots.” If you give qplot two vectors of equal lengths, qplot will draw a scatterplot for you. qplot will use the first vector as a set of x values and the second vector as a set of y values. Look for the plot to appear in the Plots tab of the bottom-right pane in your RStudio window.\nThe following code will make the plot that appears in Figure 2.1. Until now, we’ve been creating sequences of numbers with the : operator; but you can also create vectors of numbers with the c function. Give c all of the numbers that you want to appear in the vector, separated by a comma. c stands for concatenate, but you can think of it as “collect” or “combine”:\nx <- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)\nx\n## -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4  0.6  0.8  1.0\n\ny <- x^3\ny\n## -1.000 -0.512 -0.216 -0.064 -0.008  0.000  0.008\n##  0.064  0.216  0.512  1.000\n\nqplot(x, y)\n\n\n\nFigure 2.1: qplot makes a scatterplot when you give it two vectors.\n\n\nYou don’t need to name your vectors x and y. I just did that to make the example clear. As you can see in Figure 2.1, a scatterplot is a set of points, each plotted according to its x and y values. Together, the vectors x and y describe a set of 10 points. How did R match up the values in x and y to make these points? With element-wise execution, as we saw in Figure 1.3.\nScatterplots are useful for visualizing the relationship between two variables. However, we’re going to use a different type of graph, a histogram. A histogram visualizes the distribution of a single variable; it displays how many data points appear at each value of x.\nLet’s take a look at a histogram to see if this makes sense. qplot will make a histogram whenever you give it only one vector to plot. The following code makes the left-hand plot in Figure 2.2 (we’ll worry about the right-hand plot in just second). To make sure our graphs look the same, use the extra argument binwidth = 1:\nx <- c(1, 2, 2, 2, 3, 3)\nqplot(x, binwidth = 1)\n\n\n\nFigure 2.2: qplot makes a histogram when you give it a single vector.\n\n\nThis plot shows that our vector contains one value in the interval [1, 2) by placing a bar of height 1 above that interval. Similarly, the plot shows that the vector contains three values in the interval [2, 3) by placing a bar of height 3 in that interval. It shows that the vector contains two values in the interval [3, 4) by placing a bar of height 2 in that interval. In these intervals, the hard bracket, [, means that the first number is included in the interval. The parenthesis, ), means that the last number is not included.\nLet’s try another histogram. This code makes the right-hand plot in Figure 2.2. Notice that there are five points with a value of 1 in x2. The histogram displays this by plotting a bar of height 5 above the interval x2 = [1, 2):\nx2 <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)\nqplot(x2, binwidth = 1)"
  },
  {
    "objectID": "packages.html#visualize-a-histogram",
    "href": "packages.html#visualize-a-histogram",
    "title": "2  Packages and Help Pages",
    "section": "2.2 Visualize a Histogram",
    "text": "2.2 Visualize a Histogram\nLet x3 be the following vector:\nx3 <- c(0, 1, 1, 2, 2, 2, 3, 3, 4)\nImagine what a histogram of x3 would look like. Assume that the histogram has a bin width of 1. How many bars will the histogram have? Where will they appear? How high will each be?\nWhen you are done, plot a histogram of x3 with binwidth = 1, and see if you are right."
  },
  {
    "objectID": "packages.html#getting-help-with-help-pages",
    "href": "packages.html#getting-help-with-help-pages",
    "title": "2  Packages and Help Pages",
    "section": "2.3 Getting Help with Help Pages",
    "text": "2.3 Getting Help with Help Pages\nThere are over 1,000 functions at the core of R, and new R functions are created all of the time. This can be a lot of material to memorize and learn! Luckily, each R function comes with its own help page, which you can access by typing the function’s name after a question mark. For example, each of these commands will open a help page. Look for the pages to appear in the Help tab of RStudio’s bottom-right pane:\n?sqrt\n?log10\n?sample\nHelp pages contain useful information about what each function does. These help pages also serve as code documentation, so reading them can be bittersweet. They often seem to be written for people who already understand the function and do not need help.\nDon’t let this bother you—you can gain a lot from a help page by scanning it for information that makes sense and glossing over the rest. This technique will inevitably bring you to the most helpful part of each help page: the bottom. Here, almost every help page includes some example code that puts the function in action. Running this code is a great way to learn by example.\n\n\n\n\n\n\nWarning\n\n\n\nIf a function comes in an R package, R won’t be able to find its help page unless the package is loaded.\n\n\n\n2.3.1 Parts of a Help Page\nEach help page is divided into sections. Which sections appear can vary from help page to help page, but you can usually expect to find these useful topics:\nDescription - A short summary of what the function does.\nUsage - An example of how you would type the function. Each argument of the function will appear in the order R expects you to supply it (if you don’t use argument names).\nArguments - A list of each argument the function takes, what type of information R expects you to supply for the argument, and what the function will do with the information.\nDetails - A more in-depth description of the function and how it operates. The details section also gives the function author a chance to alert you to anything you might want to know when using the function.\nValue - A description of what the function returns when you run it.\nSee Also - A short list of related R functions.\nExamples - Example code that uses the function and is guaranteed to work. The examples section of a help page usually demonstrates a couple different ways to use a function. This helps give you an idea of what the function is capable of.\nIf you’d like to look up the help page for a function but have forgotten the function’s name, you can search by keyword. To do this, type two question marks followed by a keyword in R’s command line. R will pull up a list of links to help pages related to the keyword. You can think of this as the help page for the help page:\n??log\nLet’s take a stroll through sample’s help page. Remember: we’re searching for anything that could help you change the probabilities involved in the sampling process. I’m not going to reproduce the whole help page here (just the juiciest parts), so you should follow along on your computer.\nFirst, open the help page. It will appear in the same pane in RStudio as your plots did (but in the Help tab, not the Plots tab):\n?sample\nWhat do you see? Starting from the top:\nRandom Samples and Permutations\n\nDescription\n    sample takes a sample of the specified size from the elements of x using \neither with or without replacement.\nSo far, so good. You knew all of that. The next section, Usage, has a possible clue. It mentions an argument called prob:\nUsage\n    sample(x, size, replace = FALSE, prob = NULL)\nIf you scroll down to the arguments section, the description of +prob+ sounds very promising:\nA vector of probability weights for obtaining the elements of the vector being \nsampled.\nThe Details section confirms our suspicions. In this case, it also tells you how to proceed:\nThe optional prob argument can be used to give a vector of weights for obtaining \nthe elements of the vector being sampled. They need not sum to one, but they \nshould be nonnegative and not all zero.\nAlthough the help page does not say it here, these weights will be matched up to the elements being sampled in element-wise fashion. The first weight will describe the first element, the second weight the second element, and so on. This is common practice in R.\nReading on:\nIf replace is true, Walker's alias method (Ripley, 1987) is used...\nOkay, that looks like time to start skimming. We should have enough info now to figure out how to weight our dice.\n\n\n\n\n\n\nExercise: Roll a Pair of Dice\n\n\n\nRewrite the roll function below to roll a pair of weighted dice:\n\n\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\nYou will need to add a prob argument to the sample function inside of roll. This argument should tell sample to sample the numbers one through five with probability 1/8 and the number 6 with probability 3/8.\nWhen you are finished, read on for a model answer.\nTo weight your dice, you need to add a prob argument with a vector of weights to sample, like this:\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE, \n    prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))\n  sum(dice)\n}\nThis will cause roll to pick 1 through 5 with probability 1/8 and 6 with probability 3/8.\nOverwrite your previous version of roll with the new function (by running the previous code snippet in your command line). Then visualize the new long-term behavior of your dice. I’ve put the results in Figure 2.5 next to our original results:\nrolls <- replicate(10000, roll())\nqplot(rolls, binwidth = 1)\nThis confirms that we’ve effectively weighted the dice. High numbers occur much more often than low numbers. The remarkable thing is that this behavior will only be apparent when you examine long-term frequencies. On any single roll, the dice will appear to behave randomly. This is great news if you play Settlers of Catan (just tell your friends you lost the dice), but it should be disturbing if you analyze data, because it means that bias can easily occur without anyone noticing it in the short run.\n\n\n\nFigure 2.5: The dice are now clearly biased towards high numbers, since high sums occur much more often than low sums.\n\n\n\n\n2.3.2 Getting More Help\nR also comes with a super active community of users that you can turn to for help on the R-help mailing list. You can email the list with questions, but there’s a great chance that your question has already been answered. Find out by searching the archives.\nEven better than the R-help list is Stack Overflow, a website that allows programmers to answer questions and users to rank answers based on helpfulness. Personally, I find the Stack Overflow format to be more user-friendly than the R-help email list (and the respondents to be more human friendly). You can submit your own question or search through Stack Overflow’s previously answered questions related to R. There are over 30,000.\nBest of all is community.rstudio.com, a friendly, inclusive place to share questions related to R. community.rstudio.com is a very active forum focused on R. Don’t be surprised if you ask a question about an R package, and the author of the package shows up to answer.\nFor all of the R help list, Stack Overflow, and community.rstudio.com, you’re more likely to get a useful answer if you provide a reproducible example with your question. This means pasting in a short snippet of code that users can run to arrive at the bug or question you have in mind."
  },
  {
    "objectID": "packages.html#summary",
    "href": "packages.html#summary",
    "title": "2  Packages and Help Pages",
    "section": "2.4 Summary",
    "text": "2.4 Summary\nR’s packages and help pages can make you a more productive programmer. You saw in The Very Basics that R gives you the power to write your own functions that do specific things, but often the function that you want to write will already exist in an R package. Professors, programmers, and scientists have developed over 13,000 packages for you to use, which can save you valuable programming time. To use a package, you need to install it to your computer once with install.packages, and then load it into each new R session with library.\nR’s help pages will help you master the functions that appear in R and its packages. Each function and data set in R has its own help page. Although help pages often contain advanced content, they also contain valuable clues and examples that can help you learn how to use a function.\nYou have now seen enough of R to learn by doing, which is the best way to learn R. You can make your own R commands, run them, and get help when you need to understand something that I have not explained. I encourage you to experiment with your own ideas in R as you read through the next two projects."
  },
  {
    "objectID": "packages.html#project-1-wrap-up",
    "href": "packages.html#project-1-wrap-up",
    "title": "2  Packages and Help Pages",
    "section": "2.5 Project 1 Wrap-up",
    "text": "2.5 Project 1 Wrap-up\nYou’ve done more in this project than enable fraud and gambling; you’ve also learned how to speak to your computer in the language of R. R is a language like English, Spanish, or German, except R helps you talk to computers, not humans.\nYou’ve met the nouns of the R language, objects. And hopefully you guessed that functions are the verbs (I suppose function arguments would be the adverbs). When you combine functions and objects, you express a complete thought. By stringing thoughts together in a logical sequence, you can build eloquent, even artistic statements. In that respect, R is not that different than any other language.\nR shares another characteristic of human languages: you won’t feel very comfortable speaking R until you build up a vocabulary of R commands to use. Fortunately, you don’t have to be bashful. Your computer will be the only one to “hear” you speak R. Your computer is not very forgiving, but it also doesn’t judge. Not that you need to worry; you’ll broaden your R vocabulary tremendously between here and the end of the book.\nNow that you can use R, it is time to become an expert at using R to do data science. The foundation of data science is the ability to store large amounts of data and recall values on demand. From this, all else follows—manipulating data, visualizing data, modeling data, and more. However, you cannot easily store a data set in your mind by memorizing it. Nor can you easily store a data set on paper by writing it down. The only efficient way to store large amounts of data is with a computer. In fact, computers are so efficient that their development over the last three decades has completely changed the type of data we can accumulate and the methods we can use to analyze it. In short, computer data storage has driven the revolution in science that we call data science.\nProject 2: Playing Cards will make you part of this revolution by teaching you how to use R to store data sets in your computer’s memory and how to retrieve and manipulate data once it’s there."
  },
  {
    "objectID": "awosomewebsite.html",
    "href": "awosomewebsite.html",
    "title": "Project 1: Awosome Sites",
    "section": "",
    "text": "As a data scientist who knows how to program, you will improve your ability to:\n\nMemorize (store) entire data sets\nRecall data values on demand\nPerform complex calculations with large amounts of data\nDo repetitive tasks without becoming careless or bored"
  },
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "3  Github Repos",
    "section": "",
    "text": "Tutorials on implementing a few sequence-to-sequence (seq2seq) models with PyTorch and TorchText\n\n\nThis repo contains tutorials covering understanding and implementing sequence-to-sequence (seq2seq) models using PyTorch 1.8, torchtext 0.9 and spaCy 3.0, using Python 3.8.\n\n\nTutorials on implementing a few sequence-to-sequence (seq2seq) models with PyTorch and TorchText\n\n\nThis repo contains tutorials covering how to do sentiment analysis using PyTorch 1.8 and torchtext 0.9 using Python 3.7.\n\n\nA Tour of PyTorch Optimizers\n\n\nIn this repo implement different gradient descent optimization algorithms by describing how they work and then implementing them in PyTorch (using version 1.10)."
  },
  {
    "objectID": "courses.html",
    "href": "courses.html",
    "title": "4  Courses",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "websites.html",
    "href": "websites.html",
    "title": "5  Websites",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know."
  },
  {
    "objectID": "abstract.html",
    "href": "abstract.html",
    "title": "6  R Objects",
    "section": "",
    "text": "Curiously, it turns out that the classifications that we get if we use linear regression to predict a binary response will be the same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4\nValues of the odds close to 0 and ∞ indicate very low and very high probabilities of default, respectively.\nAsume p =1—that is, we have one parameter for each feature."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "7  Introduction",
    "section": "",
    "text": "However, despite their usefulness, xx are far from being a silver bullet\nHeere are a few challenges associated with them that we will explore\nIssue with Transformer and other deep learning models is opecity: As with other deep learning models, transformers are to a large extent opaque. It is hard or impossible to unravel “why” a model made a certain prediction. This is an especially hard challenge when these models are deployed to make critical decisions."
  },
  {
    "objectID": "modifying.html",
    "href": "modifying.html",
    "title": "8  Modifying Values",
    "section": "",
    "text": "Are you ready to play some games with your virtual deck? Not so fast! The point system in your deck of cards doesn’t align well with many card games. For example, in war and poker, aces are usually scored higher than kings. They’d have a point value of 14, not 1.\nIn this task, you will change the point system of your deck three times to match three different games: war, hearts, and blackjack. Each of these games will teach you something different about modifying the values inside of a data set. Start by making a copy of deck that you can manipulate. This will ensure that you always have a pristine copy of deck to fall back on (should things go awry):"
  },
  {
    "objectID": "modifying.html#changing-values-in-place",
    "href": "modifying.html#changing-values-in-place",
    "title": "8  Modifying Values",
    "section": "8.1 Changing Values in Place",
    "text": "8.1 Changing Values in Place\nYou can use R’s notation system to modify values within an R object. First, describe the value (or values) you wish to modify. Then use the assignment operator <- to overwrite those values. R will update the selected values in the original object. Let’s put this into action with a real example:\nvec <- c(0, 0, 0, 0, 0, 0)\nvec\n##  0 0 0 0 0 0\nHere’s how you can select the first value of vec:\nvec[1]\n##  0\nAnd here is how you can modify it:\nvec[1] <- 1000\nvec\n## 1000    0    0    0    0    0\nYou can replace multiple values at once as long as the number of new values equals the number of selected values:\nvec[c(1, 3, 5)] <- c(1, 1, 1)\nvec\n##  1 0 1 0 1 0\n\nvec[4:6] <- vec[4:6] + 1\nvec\n## 1 0 1 1 2 1\nYou can also create values that do not yet exist in your object. R will expand the object to accommodate the new values:\nvec[7] <- 0\nvec\n## 1 0 1 1 2 1 0\nThis provides a great way to add new variables to your data set:\ndeck2$new <- 1:52\n\nhead(deck2)\n##   face   suit value new\n##   king spades    13   1\n##  queen spades    12   2\n##   jack spades    11   3\n##    ten spades    10   4\n##   nine spades     9   5\n##  eight spades     8   6\nYou can also remove columns from a data frame (and elements from a list) by assigning them the symbol NULL:\ndeck2$new <- NULL\n\nhead(deck2)\n##   face   suit value\n##   king spades    13\n##  queen spades    12\n##   jack spades    11\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\nIn the game of war, aces are king (figuratively speaking). They receive the highest value of all the cards, which would be something like 14. Every other card gets the value that it already has in deck. To play war, you just need to change the values of your aces from 1 to 14.\nAs long as you haven’t shuffled your deck, you know just where the aces are. They appear every 13 cards. Hence, you can describe them with R’s notation system:\ndeck2[c(13, 26, 39, 52), ]\n##  face     suit value\n##   ace   spades     1\n##   ace    clubs     1\n##   ace diamonds     1\n##   ace   hearts     1\nYou can single out just the values of the aces by subsetting the columns dimension of deck2. Or, even better, you can subset the column vector deck2$value:\ndeck2[c(13, 26, 39, 52), 3]\n## 1 1 1 1\n\ndeck2$value[c(13, 26, 39, 52)]\n## 1 1 1 1\nNow all you have to do is assign a new set of values to these old values. The set of new values will have to be the same size as the set of values that you are replacing. So you could save c(14, 14, 14, 14) into the ace values, or you could just save 14 and rely on R’s recycling rules to expand 14 to c(14, 14, 14, 14):\ndeck2$value[c(13, 26, 39, 52)] <- c(14, 14, 14, 14)\n\n# or\n\ndeck2$value[c(13, 26, 39, 52)] <- 14\nNotice that the values change in place. You don’t end up with a modified copy of deck2; the new values will appear inside deck2:\nhead(deck2, 13)\n##   face   suit value\n##   king spades    13\n##  queen spades    12\n##   jack spades    11\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\n##  seven spades     7\n##    six spades     6\n##   five spades     5\n##   four spades     4\n##  three spades     3\n##    two spades     2\n##    ace spades    14\nThe same technique will work whether you store your data in a vector, matrix, array, list, or data frame. Just describe the values that you want to change with R’s notation system, then assign over those values with R’s assignment operator.\nThings worked very easily in this example because you knew exactly where each ace was. The cards were sorted in an orderly manner and an ace appeared every 13 rows.\nBut what if the deck had been shuffled? You could look through all the cards and note the locations of the aces, but that would be tedious. If your data frame were larger, it might be impossible:\ndeck3 <- shuffle(deck)\nWhere are the aces now?\nhead(deck3)\n##  face     suit value\n## queen    clubs    12\n##  king    clubs    13\n##   ace   spades     1   # an ace\n##  nine    clubs     9\n## seven   spades     7\n## queen diamonds    12\nWhy not ask R to find the aces for you? You can do this with logical subsetting. Logical subsetting provides a way to do targeted extraction and modification with R objects, a sort of search-and-destroy mission inside your own data sets."
  },
  {
    "objectID": "modifying.html#logical-subsetting",
    "href": "modifying.html#logical-subsetting",
    "title": "8  Modifying Values",
    "section": "8.2 Logical Subsetting",
    "text": "8.2 Logical Subsetting\nDo you remember R’s logical index system, logicals? To recap, you can select values with a vector of TRUEs and FALSEs. The vector must be the same length as the dimension that you wish to subset. R will return every element that matches a TRUE:\nvec\n## 1 0 1 1 2 1 0\n\nvec[c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n## 2\nAt first glance, this system might seem impractical. Who wants to type out long vectors of TRUEs and FALSEs? No one. But you don’t have to. You can let a logical test create a vector of TRUEs and FALSEs for you.\n\n8.2.1 Logical Tests\nA logical test is a comparison like “is one less than two?”, 1 < 2, or “is three greater than four?”, 3 > 4. R provides seven logical operators that you can use to make comparisons, shown in Table 8.1.\n\n\nTable 8.1: R’s Logical Operators\n\n\nOperator\nSyntax\nTests\n\n\n\n\n>\na > b\nIs a greater than b?\n\n\n>=\na >= b\nIs a greater than or equal to b?\n\n\n<\na < b\nIs a less than b?\n\n\n<=\na <= b\nIs a less than or equal to b?\n\n\n==\na == b\nIs a equal to b?\n\n\n!=\na != b\nIs a not equal to b?\n\n\n%in%\na %in% c(a, b, c)\nIs a in the group c(a, b, c)?\n\n\n\n\nEach operator returns a TRUE or a FALSE. If you use an operator to compare vectors, R will do element-wise comparisons—just like it does with the arithmetic operators:\n1 > 2\n## FALSE\n\n1 > c(0, 1, 2)\n## TRUE FALSE FALSE\n\nc(1, 2, 3) == c(3, 2, 1)\n## FALSE  TRUE FALSE\n%in% is the only operator that does not do normal element-wise execution. %in% tests whether the value(s) on the left side are in the vector on the right side. If you provide a vector on the left side, %in% will not pair up the values on the left with the values on the right and then do element-wise tests. Instead, %in% will independently test whether each value on the left is somewhere in the vector on the right:\n1 %in% c(3, 4, 5)\n## FALSE\n\nc(1, 2) %in% c(3, 4, 5)\n## FALSE FALSE\n\nc(1, 2, 3) %in% c(3, 4, 5)\n## FALSE FALSE  TRUE\n\nc(1, 2, 3, 4) %in% c(3, 4, 5)\n## FALSE FALSE  TRUE  TRUE\nNotice that you test for equality with a double equals sign, ==, and not a single equals sign, =, which is another way to write <-. It is easy to forget and use a = b to test if a equals b. Unfortunately, you’ll be in for a nasty surprise. R won’t return a TRUE or FALSE, because it won’t have to: a will equal b, because you just ran the equivalent of a <- b.\n\n\n\n\n\n\n= is an assignment operator\n\n\n\nBe careful not to confuse = with ==. = does the same thing as <-: it assigns a value to an object.\n\n\nYou can compare any two R objects with a logical operator; however, logical operators make the most sense if you compare two objects of the same data type. If you compare objects of different data types, R will use its coercion rules to coerce the objects to the same type before it makes the comparison.\n\n\n\n\n\n\nExercise: How many Aces?\n\n\n\nExtract the face column of deck2 and test whether each value is equal to ace. As a challenge, use R to quickly count how many cards are equal to ace.\n\n\nYou can extract the face column with R’s $ notation:\ndeck2$face\n##  \"king\"  \"queen\" \"jack\"  \"ten\"   \"nine\" \n##  \"eight\" \"seven\" \"six\"   \"five\"  \"four\" \n##  \"three\" \"two\"   \"ace\"   \"king\"  \"queen\"\n##  \"jack\"  \"ten\"   \"nine\"  \"eight\" \"seven\"\n##  \"six\"   \"five\"  \"four\"  \"three\" \"two\"  \n##  \"ace\"   \"king\"  \"queen\" \"jack\"  \"ten\"  \n##  \"nine\"  \"eight\" \"seven\" \"six\"   \"five\" \n##  \"four\"  \"three\" \"two\"   \"ace\"   \"king\" \n##  \"queen\" \"jack\"  \"ten\"   \"nine\"  \"eight\"\n##  \"seven\" \"six\"   \"five\"  \"four\"  \"three\"\n##  \"two\"   \"ace\"\nNext, you can use the == operator to test whether each value is equal to ace. In the following code, R will use its recycling rules to indivuidually compare every value of deck2$face to \"ace\". Notice that the quotation marks are important. If you leave them out, R will try to find an object named ace to compare against deck2$face:\ndeck2$face == \"ace\"\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE  TRUE\nYou can use sum to quickly count the number of TRUEs in the previous vector. Remember that R will coerce logicals to numerics when you do math with them. R will turn TRUEs into ones and FALSEs into zeroes. As a result, sum will count the number of TRUEs:\nsum(deck2$face == \"ace\")\n## 4\nYou can use this method to spot and then change the aces in your deck—even if you’ve shuffled your cards. First, build a logical test that identifies the aces in your shuffled deck:\ndeck3$face == \"ace\"\nThen use the test to single out the ace point values. Since the test returns a logical vector, you can use it as an index:\ndeck3$value[deck3$face == \"ace\"]\n##  1 1 1 1\nFinally, use assignment to change the ace values in deck3:\ndeck3$value[deck3$face == \"ace\"] <- 14\n\nhead(deck3)\n##  face     suit value\n## queen    clubs    12\n##  king    clubs    13\n##   ace   spades    14  # an ace\n##  nine    clubs     9\n## seven   spades     7\n## queen diamonds    12\nTo summarize, you can use a logical test to select values within an object.\nLogical subsetting is a powerful technique because it lets you quickly identify, extract, and modify individual values in your data set. When you work with logical subsetting, you do not need to know where in your data set a value exists. You only need to know how to describe the value with a logical test.\nLogical subsetting is one of the things R does best. In fact, logical subsetting is a key component of vectorized programming, a coding style that lets you write fast and efficient R code, which we will study in Speed.\nLet’s put logical subsetting to use with a new game: hearts. In hearts, every card has a value of zero:\ndeck4 <- deck\ndeck4$value <- 0\n\nhead(deck4, 13)\n##   face   suit value\n##   king spades     0\n##  queen spades     0\n##   jack spades     0\n##    ten spades     0\n##   nine spades     0\n##  eight spades     0\n##  seven spades     0\n##    six spades     0\n##   five spades     0\n##   four spades     0\n##  three spades     0\n##    two spades     0\n##    ace spades     0\nexcept cards in the suit of hearts and the queen of spades. Each card in the suit of hearts has a value of 1. Can you find these cards and replace their values? Give it a try.\n\n\n\n\n\n\nExercise: Score the Deck for Hearts\n\n\n\nAssign a value of 1 to every card in deck4 that has a suit of hearts.\n\n\nTo do this, first write a test that identifies cards in the hearts suit:\ndeck4$suit == \"hearts\"\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n##   TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n##   TRUE  TRUE  TRUE\nThen use your test to select the values of these cards:\ndeck4$value[deck4$suit == \"hearts\"]\n## 0 0 0 0 0 0 0 0 0 0 0 0 0\nFinally, assign a new number to these values:\ndeck4$value[deck4$suit == \"hearts\"] <- 1\nNow all of your hearts cards have been updated:\ndeck4$value[deck4$suit == \"hearts\"]\n## 1 1 1 1 1 1 1 1 1 1 1 1 1\nIn hearts, the queen of spades has the most unusual value of all: she’s worth 13 points. It should be simple to change her value, but she’s surprisingly hard to find. You could find all of the queens:\ndeck4[deck4$face == \"queen\", ]\n##   face     suit value\n##  queen   spades     0\n##  queen    clubs     0\n##  queen diamonds     0\n##  queen   hearts     1\nBut that’s three cards too many. On the other hand, you could find all of the cards in spades:\ndeck4[deck4$suit == \"spades\", ]\n##   face   suit value\n##   king spades     0\n##  queen spades     0\n##   jack spades     0\n##    ten spades     0\n##   nine spades     0\n##  eight spades     0\n##  seven spades     0\n##    six spades     0\n##   five spades     0\n##   four spades     0\n##  three spades     0\n##    two spades     0\n##    ace spades     0\nBut that’s 12 cards too many. What you really want to find is all of the cards that have both a face value equal to queen and a suit value equal to spades. You can do that with a Boolean operator. Boolean operators combine multiple logical tests together into a single test.\n\n\n8.2.2 Boolean Operators\nBoolean operators are things like and (&) and or (|). They collapse the results of multiple logical tests into a single TRUE or FALSE. R has six boolean operators, shown in Table 8.2.\n\n\nTable 8.2: Boolean operators\n\n\n\n\n\n\n\nOperator\nSyntax\nTests\n\n\n\n\n&\ncond1 & cond2\nAre both cond1 and cond2 true?\n\n\n|\ncond1 | cond2\nIs one or more of cond1 and cond2 true?\n\n\nxor\nxor(cond1, cond2)\nIs exactly one of cond1 and cond2 true?\n\n\n!\n!cond1\nIs cond1 false? (e.g., ! flips the results of a logical test)\n\n\nany\nany(cond1, cond2, cond3, ...)\nAre any of the conditions true?\n\n\nall\nall(cond1, cond2, cond3, ...)\nAre all of the conditions true?\n\n\n\n\nTo use a Boolean operator, place it between two complete logical tests. R will execute each logical test and then use the Boolean operator to combine the results into a single TRUE or FALSE, Figure 8.1.\n\n\n\n\n\n\nThe most common mistake with Boolean operators\n\n\n\nIt is easy to forget to put a complete test on either side of a Boolean operator. In English, it is efficient to say “Is x greater than two and less than nine?” But in R, you need to write the equivalent of “Is x greater than two and is x less than nine?” This is shown in Figure 8.1.\n\n\n\n\n\nFigure 8.1: R will evaluate the expressions on each side of a Boolean operator separately, and then combine the results into a single TRUE or FALSE. If you do not supply a complete test to each side of the operator, R will return an error.\n\n\nWhen used with vectors, Boolean operators will follow the same element-wise execution as arithmetic and logical operators:\na <- c(1, 2, 3)\nb <- c(1, 2, 3)\nc <- c(1, 2, 4)\n\na == b\n##  TRUE TRUE TRUE\n\nb == c\n##  TRUE  TRUE FALSE\n\na == b & b == c\n##  TRUE  TRUE FALSE\nCould you use a Boolean operator to locate the queen of spades in your deck? Of course you can. You want to test each card to see if it is both a queen and a spade. You can write this test in R with:\ndeck4$face == \"queen\" & deck4$suit == \"spades\"\n##  FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE\nI’ll save the results of this test to its own object. That will make the results easier to work with:\nqueenOfSpades <- deck4$face == \"queen\" & deck4$suit == \"spades\"\nNext, you can use the test as an index to select the value of the queen of spades. Make sure the test actually selects the correct value:\ndeck4[queenOfSpades, ]\n##  face   suit value\n## queen spades     0\n\ndeck4$value[queenOfSpades]\n## 0\nNow that you’ve found the queen of spades, you can update her value:\ndeck4$value[queenOfSpades] <- 13\n\ndeck4[queenOfSpades, ]\n##  face   suit value\n## queen spades     13\nYour deck is now ready to play hearts.\n\n\n\n\n\n\nExercise: Practice with Tests\n\n\n\nIf you think you have the hang of logical tests, try converting these sentences into tests written with R code. To help you out, I’ve defined some R objects after the sentences that you can use to test your answers:\n\nIs w positive?\nIs x greater than 10 and less than 20?\nIs object y the word February?\nIs every value in z a day of the week?\n\n\n\nw <- c(-1, 0, 1)\nx <- c(5, 15)\ny <- \"February\"\nz <- c(\"Monday\", \"Tuesday\", \"Friday\")\nHere are some model answers. If you got stuck, be sure to re-read how R evaluates logical tests that use Boolean values:\nw > 0\n10 < x & x < 20\ny == \"February\"\nall(z %in% c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \n  \"Saturday\", \"Sunday\"))\nLet’s consider one last game, blackjack. In blackjack, each number card has a value equal to its face value. Each face card (king, queen, or jack) has a value of 10. Finally, each ace has a value of 11 or 1, depending on the final results of the game.\nLet’s begin with a fresh copy of deck—that way the number cards (two through ten) will start off with the correct value:\ndeck5 <- deck\n\nhead(deck5, 13)\n##   king spades    13\n##  queen spades    12\n##   jack spades    11\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\n##  seven spades     7\n##    six spades     6\n##   five spades     5\n##   four spades     4\n##  three spades     3\n##    two spades     2\n##    ace spades     1\nYou can change the value of the face cards in one fell swoop with %in%:\nfacecard <- deck5$face %in% c(\"king\", \"queen\", \"jack\")\n\ndeck5[facecard, ]\n##   face     suit value\n##   king   spades    13\n##  queen   spades    12\n##   jack   spades    11\n##   king    clubs    13\n##  queen    clubs    12\n##   jack    clubs    11\n##   king diamonds    13\n##  queen diamonds    12\n##   jack diamonds    11\n##   king   hearts    13\n##  queen   hearts    12\n##   jack   hearts    11\n\ndeck5$value[facecard] <- 10\n\nhead(deck5, 13)\n##   face   suit value\n##   king spades    10\n##  queen spades    10\n##   jack spades    10\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\n##  seven spades     7\n##    six spades     6\n##   five spades     5\n##   four spades     4\n##  three spades     3\n##    two spades     2\n##    ace spades     1\nNow you just need to fix the ace values—or do you? It is hard to decide what value to give the aces because their exact value will change from hand to hand. At the end of each hand, an ace will equal 11 if the sum of the player’s cards does not exceed 21. Otherwise, the ace will equal 1. The actual value of the ace will depend on the other cards in the player’s hand. This is a case of missing information. At the moment, you do not have enough information to assign a correct point value to the ace cards."
  },
  {
    "objectID": "modifying.html#sec-missing",
    "href": "modifying.html#sec-missing",
    "title": "8  Modifying Values",
    "section": "8.3 Missing Information",
    "text": "8.3 Missing Information\nMissing information problems happen frequently in data science. Usually, they are more straightforward: you don’t know a value because the measurement was lost, corrupted, or never taken to begin with. R has a way to help you manage these missing values.\nThe NA character is a special symbol in R. It stands for “not available” and can be used as a placeholder for missing information. R will treat NA exactly as you should want missing information treated. For example, what result would you expect if you add 1 to a piece of missing information?\n1 + NA\n## NA\nR will return a second piece of missing information. It would not be correct to say that 1 + NA = 1 because there is a good chance that the missing quantity is not zero. You do not have enough information to determine the result.\nWhat if you tested whether a piece of missing information is equal to 1?\nNA == 1\n## NA\nAgain, your answer would be something like “I do not know if this is equal to one,” that is, NA. Generally, NAs will propagate whenever you use them in an R operation or function. This can save you from making errors based on missing data.\n\n8.3.1 na.rm\nMissing values can help you work around holes in your data sets, but they can also create some frustrating problems. Suppose, for example, that you’ve collected 1,000 observations and wish to take their average with R’s mean function. If even one of the values is NA, your result will be NA:\nc(NA, 1:50)\n## NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n## 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n## 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\nmean(c(NA, 1:50))\n## NA\nUnderstandably, you may prefer a different behavior. Most R functions come with the optional argument, na.rm, which stands for NA remove. R will ignore NAs when it evaluates a function if you add the argument na.rm = TRUE:\nmean(c(NA, 1:50), na.rm = TRUE)\n## 25.5\n\n\n8.3.2 is.na\nOn occasion, you may want to identify the NAs in your data set with a logical test, but that too creates a problem. How would you go about it? If something is a missing value, any logical test that uses it will return a missing value, even this test:\nNA == NA\n## NA\nWhich means that tests like this won’t help you find missing values:\nc(1, 2, 3, NA) == NA\n## NA NA NA NA\nBut don’t worry too hard; R supplies a special function that can test whether a value is an NA. The function is sensibly named is.na:\nis.na(NA)\n## TRUE\n\nvec <- c(1, 2, 3, NA)\nis.na(vec)\n## FALSE FALSE FALSE  TRUE\nLet’s set all of your ace values to NA. This will accomplish two things. First, it will remind you that you do not know the final value of each ace. Second, it will prevent you from accidentally scoring a hand that has an ace before you determine the ace’s final value.\nYou can set your ace values to NA in the same way that you would set them to a number:\ndeck5$value[deck5$face == \"ace\"] <- NA\n\nhead(deck5, 13)\n##   face   suit value\n##   king spades    10\n##  queen spades    10\n##   jack spades    10\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\n##  seven spades     7\n##    six spades     6\n##   five spades     5\n##   four spades     4\n##  three spades     3\n##    two spades     2\n##    ace spades    NA\nCongratulations. Your deck is now ready for a game of blackjack."
  },
  {
    "objectID": "modifying.html#summary",
    "href": "modifying.html#summary",
    "title": "8  Modifying Values",
    "section": "8.4 Summary",
    "text": "8.4 Summary\nYou can modify values in place inside an R object when you combine R’s notation syntax with the assignment operator, <-. This lets you update your data and clean your data sets\nWhen you work with large data sets, modifying and retrieving values creates a logistical problem of its own. How can you search through the data to find the values that you want to modify or retrieve? As an R user, you can do this with logical subsetting. Create a logical test with logical and Boolean operators and then use the test as an index in R’s bracket notation. R will return the values that you are looking for, even if you do not know where they are.\nRetrieving individual values will not be your only concern as an R programmer. You’ll also need to retrieve entire data sets themselves; for example, you may call one in a function. Environments will teach you how R looks up and saves data sets and other R objects in its environment system. You’ll then use this knowledge to fix the deal and shuffle functions."
  },
  {
    "objectID": "environments.html",
    "href": "environments.html",
    "title": "9  Environments",
    "section": "",
    "text": "Your deck is now ready for a game of blackjack (or hearts or war), but are your shuffle and deal functions up to snuff? Definitely not. For example, deal deals the same card over and over again:\nAnd the shuffle function doesn’t actually shuffle deck (it returns a copy of deck that has been shuffled). In short, both of these functions use deck, but neither manipulates deck—and we would like them to.\nTo fix these functions, you will need to learn how R stores, looks up, and manipulates objects like deck. R does all of these things with the help of an environment system."
  },
  {
    "objectID": "environments.html#environments",
    "href": "environments.html#environments",
    "title": "9  Environments",
    "section": "9.1 Environments",
    "text": "9.1 Environments\nConsider for a moment how your computer stores files. Every file is saved in a folder, and each folder is saved in another folder, which forms a hierarchical file system. If your computer wants to open up a file, it must first look up the file in this file system.\nYou can see your file system by opening a finder window. For example, Figure 9.1 shows part of the file system on my computer. I have tons of folders. Inside one of them is a subfolder named Documents, inside of that subfolder is a sub-subfolder named ggsubplot, inside of that folder is a folder named inst, inside of that is a folder named doc, and inside of that is a file named manual.pdf.\n\n\n\nFigure 9.1: Your computer arranges files into a hierarchy of folders and subfolders. To look at a file, you need to find where it is saved in the file system.\n\n\nR uses a similar system to save R objects. Each object is saved inside of an environment, a list-like object that resembles a folder on your computer. Each environment is connected to a parent environment, a higher-level environment, which creates a hierarchy of environments.\nYou can see R’s environment system with the parenvs function in the pryr package (note parenvs came in the pryr package when this book was first published). parenvs(all = TRUE) will return a list of the environments that your R session is using. The actual output will vary from session to session depending on which packages you have loaded. Here’s the output from my current session:\nlibrary(pryr)\nparenvs(all = TRUE)\n##    label                            name               \n## 1  <environment: R_GlobalEnv>       \"\"                 \n## 2  <environment: package:pryr>  \"package:pryr\" \n## 3  <environment: 0x7fff3321c388>    \"tools:rstudio\"    \n## 4  <environment: package:stats>     \"package:stats\"    \n## 5  <environment: package:graphics>  \"package:graphics\" \n## 6  <environment: package:grDevices> \"package:grDevices\"\n## 7  <environment: package:utils>     \"package:utils\"    \n## 8  <environment: package:datasets>  \"package:datasets\" \n## 9  <environment: package:methods>   \"package:methods\"  \n## 10 <environment: 0x7fff3193dab0>    \"Autoloads\"        \n## 11 <environment: base>              \"\"                 \n## 12 <environment: R_EmptyEnv>        \"\"                 \nIt takes some imagination to interpret this output, so let’s visualize the environments as a system of folders, Figure 9.2. You can think of the environment tree like this. The lowest-level environment is named R_GlobalEnv and is saved inside an environment named package:pryr, which is saved inside the environment named 0x7fff3321c388, and so on, until you get to the final, highest-level environment, R_EmptyEnv. R_EmptyEnv is the only R environment that does not have a parent environment.\n\n\n\nFigure 9.2: R stores R objects in an environment tree that resembles your computer’s folder system.\n\n\nRemember that this example is just a metaphor. R’s environments exist in your RAM memory, and not in your file system. Also, R environments aren’t technically saved inside one another. Each environment is connected to a parent environment, which makes it easy to search up R’s environment tree. But this connection is one-way: there’s no way to look at one environment and tell what its “children” are. So you cannot search down R’s environment tree. In other ways, though, R’s environment system works similar to a file system."
  },
  {
    "objectID": "environments.html#working-with-environments",
    "href": "environments.html#working-with-environments",
    "title": "9  Environments",
    "section": "9.2 Working with Environments",
    "text": "9.2 Working with Environments\nR comes with some helper functions that you can use to explore your environment tree. First, you can refer to any of the environments in your tree with as.environment. as.environment takes an environment name (as a character string) and returns the corresponding environment:\nas.environment(\"package:stats\")\n## <environment: package:stats>\n## attr(,\"name\")\n## [1] \"package:stats\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats\"\nThree environments in your tree also come with their own accessor functions. These are the global environment (R_GlobalEnv), the base environment (base), and the empty environment (R_EmptyEnv). You can refer to them with:\nglobalenv()\n## <environment: R_GlobalEnv>\n\nbaseenv()\n## <environment: base>\n\nemptyenv()\n##<environment: R_EmptyEnv>\nNext, you can look up an environment’s parent with parent.env:\nparent.env(globalenv())\n## <environment: package:pryr>\n## attr(,\"name\")\n## [1] \"package:pryr\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr\"\nNotice that the empty environment is the only R environment without a parent:\nparent.env(emptyenv())\n## Error in parent.env(emptyenv()) : the empty environment has no parent\nYou can view the objects saved in an environment with ls or ls.str. ls will return just the object names, but ls.str will display a little about each object’s structure:\nls(emptyenv())\n## character(0)\n\nls(globalenv())\n##  \"deal\"    \"deck\"    \"deck2\"   \"deck3\"   \"deck4\"   \"deck5\"  \n##  \"die\"     \"gender\"  \"hand\"    \"lst\"     \"mat\"     \"mil\"    \n##  \"new\"     \"now\"     \"shuffle\" \"vec\"  \nThe empty environment is—not surprisingly—empty; the base environment has too many objects to list here; and the global environment has some familiar faces. It is where R has saved all of the objects that you’ve created so far.\n\n\n\n\n\n\nTip\n\n\n\nRStudio’s environment pane displays all of the objects in your global environment.\n\n\nYou can use R’s $ syntax to access an object in a specific environment. For example, you can access deck from the global environment:\nhead(globalenv()$deck, 3)\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\nAnd you can use the assign function to save an object into a particular environment. First give assign the name of the new object (as a character string). Then give assign the value of the new object, and finally the environment to save the object in:\nassign(\"new\", \"Hello Global\", envir = globalenv())\n\nglobalenv()$new\n## \"Hello Global\"\nNotice that assign works similar to <-. If an object already exists with the given name in the given environment, assign will overwrite it without asking for permission. This makes assign useful for updating objects but creates the potential for heartache.\nNow that you can explore R’s environment tree, let’s examine how R uses it. R works closely with the environment tree to look up objects, store objects, and evaluate functions. How R does each of these tasks will depend on the current active environment.\n\n9.2.1 The Active Environment\nAt any moment of time, R is working closely with a single environment. R will store new objects in this environment (if you create any), and R will use this environment as a starting point to look up existing objects (if you call any). I’ll call this special environment the active environment. The active environment is usually the global environment, but this may change when you run a function.\nYou can use environment to see the current active environment:\nenvironment()\n<environment: R_GlobalEnv>\nThe global environment plays a special role in R. It is the active environment for every command that you run at the command line. As a result, any object that you create at the command line will be saved in the global environment. You can think of the global environment as your user workspace.\nWhen you call an object at the command line, R will look for it first in the global environment. But what if the object is not there? In that case, R will follow a series of rules to look up the object."
  },
  {
    "objectID": "environments.html#scoping-rules",
    "href": "environments.html#scoping-rules",
    "title": "9  Environments",
    "section": "9.3 Scoping Rules",
    "text": "9.3 Scoping Rules\nR follows a special set of rules to look up objects. These rules are known as R’s scoping rules, and you’ve already met a couple of them:\n\nR looks for objects in the current active environment.\nWhen you work at the command line, the active environment is the global environment. Hence, R looks up objects that you call at the command line in the global environment.\n\nHere is a third rule that explains how R finds objects that are not in the active environment\n\nWhen R does not find an object in an environment, R looks in the environment’s parent environment, then the parent of the parent, and so on, until R finds the object or reaches the empty environment.\n\nSo, if you call an object at the command line, R will look for it in the global environment. If R can’t find it there, R will look in the parent of the global environment, and then the parent of the parent, and so on, working its way up the environment tree until it finds the object, as in Figure 9.3. If R cannot find the object in any environment, it will return an error that says the object is not found.\n\n\n\nFigure 9.3: R will search for an object by name in the active environment, here the global environment. If R does not find the object there, it will search in the active environment’s parent, and then the parent’s parent, and so on until R finds the object or runs out of environments.\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that functions are a type of object in R. R will store and look up functions the same way it stores and looks up other objects, by searching for them by name in the environment tree."
  },
  {
    "objectID": "environments.html#assignment",
    "href": "environments.html#assignment",
    "title": "9  Environments",
    "section": "9.4 Assignment",
    "text": "9.4 Assignment\nWhen you assign a value to an object, R saves the value in the active environment under the object’s name. If an object with the same name already exists in the active environment, R will overwrite it.\nFor example, an object named new exists in the global environment:\nnew\n## \"Hello Global\"\nYou can save a new object named new to the global environment with this command. R will overwrite the old object as a result:\nnew <- \"Hello Active\"\n\nnew\n## \"Hello Active\"\nThis arrangement creates a quandary for R whenever R runs a function. Many functions save temporary objects that help them do their jobs. For example, the roll function from Project 1: Weighted Dice saved an object named die and an object named dice:\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\nR must save these temporary objects in the active environment; but if R does that, it may overwrite existing objects. Function authors cannot guess ahead of time which names may already exist in your active environment. How does R avoid this risk? Every time R runs a function, it creates a new active environment to evaluate the function in."
  },
  {
    "objectID": "environments.html#evaluation",
    "href": "environments.html#evaluation",
    "title": "9  Environments",
    "section": "9.5 Evaluation",
    "text": "9.5 Evaluation\nR creates a new environment each time it evaluates a function. R will use the new environment as the active environment while it runs the function, and then R will return to the environment that you called the function from, bringing the function’s result with it. Let’s call these new environments runtime environments because R creates them at runtime to evaluate functions.\nWe’ll use the following function to explore R’s runtime environments. We want to know what the environments look like: what are their parent environments, and what objects do they contain? show_env is designed to tell us:\nshow_env <- function(){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\nshow_env is itself a function, so when we call show_env(), R will create a runtime environment to evaluate the function in. The results of show_env will tell us the name of the runtime environment, its parent, and which objects the runtime environment contains:\nshow_env()\n## $ran.in\n## <environment: 0x7ff711d12e28>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\nThe results reveal that R created a new environment named 0x7ff711d12e28 to run show_env() in. The environment had no objects in it, and its parent was the global environment. So for purposes of running show_env, R’s environment tree looked like Figure 9.4.\nLet’s run show_env again:\nshow_env()\n## $ran.in\n## <environment: 0x7ff715f49808>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\nThis time show_env ran in a new environment, 0x7ff715f49808. R creates a new environment each time you run a function. The 0x7ff715f49808 environment looks exactly the same as 0x7ff711d12e28. It is empty and has the same global environment as its parent.\n\n\n\nFigure 9.4: R creates a new environment to run show_env in. The environment is a child of the global environment.\n\n\nNow let’s consider which environment R will use as the parent of the runtime environment.\nR will connect a function’s runtime environment to the environment that the function was first created in. This environment plays an important role in the function’s life—because all of the function’s runtime environments will use it as a parent. Let’s call this environment the origin environment. You can look up a function’s origin environment by running environment on the function:\nenvironment(show_env)\n## <environment: R_GlobalEnv>\nThe origin environment of show_env is the global environment because we created show_env at the command line, but the origin environment does not need to be the global environment. For example, the environment of parenvs is the pryr package:\nenvironment(parenvs)\n## <environment: namespace:pryr>\nIn other words, the parent of a runtime environment will not always be the global environment; it will be whichever environment the function was first created in.\nFinally, let’s look at the objects contained in a runtime environment. At the moment, show_env’s runtime environments do not contain any objects, but that is easy to fix. Just have show_env create some objects in its body of code. R will store any objects created by show_env in its runtime environment. Why? Because the runtime environment will be the active environment when those objects are created:\nshow_env <- function(){\n  a <- 1\n  b <- 2\n  c <- 3\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\nThis time when we run show_env, R stores a, b, and c in the runtime environment:\nshow_env()\n## $ran.in\n## <environment: 0x7ff712312cd0>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n## a :  num 1\n## b :  num 2\n## c :  num 3\nThis is how R ensures that a function does not overwrite anything that it shouldn’t. Any objects created by the function are stored in a safe, out-of-the-way runtime environment.\nR will also put a second type of object in a runtime environment. If a function has arguments, R will copy over each argument to the runtime environment. The argument will appear as an object that has the name of the argument but the value of whatever input the user provided for the argument. This ensures that a function will be able to find and use each of its arguments:\nfoo <- \"take me to your runtime\"\n\nshow_env <- function(x = foo){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\n\nshow_env()\n## $ran.in\n## <environment: 0x7ff712398958>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n## x :  chr \"take me to your runtime\"\nLet’s put this all together to see how R evaluates a function. Before you call a function, R is working in an active environment; let’s call this the calling environment. It is the environment R calls the function from.\nThen you call the function. R responds by setting up a new runtime environment. This environment will be a child of the function’s origin enviornment. R will copy each of the function’s arguments into the runtime environment and then make the runtime environment the new active environment.\nNext, R runs the code in the body of the function. If the code creates any objects, R stores them in the active, that is, runtime environment. If the code calls any objects, R uses its scoping rules to look them up. R will search the runtime environment, then the parent of the runtime environment (which will be the origin environment), then the parent of the origin environment, and so on. Notice that the calling environment might not be on the search path. Usually, a function will only call its arguments, which R can find in the active runtime environment.\nFinally, R finishes running the function. It switches the active environment back to the calling environment. Now R executes any other commands in the line of code that called the function. So if you save the result of the function to an object with <-, the new object will be stored in the calling environment.\nTo recap, R stores its objects in an environment system. At any moment of time, R is working closely with a single active environment. It stores new objects in this environment, and it uses the environment as a starting point when it searches for existing objects. R’s active environment is usually the global environment, but R will adjust the active environment to do things like run functions in a safe manner.\nHow can you use this knowledge to fix the deal and shuffle functions?\nFirst, let’s start with a warm-up question. Suppose I redefine deal at the command line like this:\ndeal <- function() {\n  deck[1, ]\n}\nNotice that deal no longer takes an argument, and it calls the deck object, which lives in the global environment.\n\n\n\n\n\n\nExercise: Will deal work?\n\n\n\nWill R be able to find deck and return an answer when I call the new version of deal, such as deal()?\n\n\nYes. deal will still work the same as before. R will run deal in a runtime environment that is a child of the global environment. Why will it be a child of the global environment? Because the global environment is the origin environment of deal (we defined deal in the global environment):\nenvironment(deal)\n## <environment: R_GlobalEnv>\nWhen deal calls deck, R will need to look up the deck object. R’s scoping rules will lead it to the version of deck in the global environment, as in Figure 9.5. deal works as expected as a result:\ndeal()\n##  face   suit value\n##  king spades    13\n\n\n\nFigure 9.5: R finds deck by looking in the parent of deal’s runtime environment. The parent is the global environment, deal’s origin environment. Here, R finds the copy of deck.\n\n\nNow let’s fix the deal function to remove the cards it has dealt from deck. Recall that deal returns the top card of deck but does not remove the card from the deck. As a result, deal always returns the same card:\ndeal()\n##  face   suit value\n##  king spades    13\n\ndeal()\n##  face   suit value\n##  king spades    13\nYou know enough R syntax to remove the top card of deck. The following code will save a prisitine copy of deck and then remove the top card:\nDECK <- deck\n\ndeck <- deck[-1, ]\n\nhead(deck, 3)\n##  face   suit value\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\nNow let’s add the code to deal. Here deal saves (and then returns) the top card of deck. In between, it removes the card from deck…or does it?\ndeal <- function() {\n  card <- deck[1, ]\n  deck <- deck[-1, ]\n  card\n}\nThis code won’t work because R will be in a runtime environment when it executes deck <- deck[-1, ]. Instead of overwriting the global copy of deck with deck[-1, ], deal will just create a slightly altered copy of deck in its runtime environment, as in Figure 9.6.\n\n\n\nFigure 9.6: The deal function looks up deck in the global environment but saves deck[-1, ] in the runtime environment as a new object named deck.\n\n\n\n\n\n\n\n\nExercise: Overwrite deck\n\n\n\nRewrite the deck <- deck[-1, ] line of deal to assign deck[-1, ] to an object named deck in the global environment. Hint: consider the assign function.\n\n\nYou can assign an object to a specific environment with the assign function:\ndeal <- function() {\n  card <- deck[1, ]\n  assign(\"deck\", deck[-1, ], envir = globalenv())\n  card\n}\nNow deal will finally clean up the global copy of deck, and we can deal cards just as we would in real life:\ndeal()\n##  face   suit value\n## queen spades    12\n\ndeal()\n## face   suit value\n## jack spades    11\n\ndeal()\n## face   suit value\n##  ten spades    10\nLet’s turn our attention to the shuffle function:\nshuffle <- function(cards) { \n  random <- sample(1:52, size = 52)\n  cards[random, ]\n}\nshuffle(deck) doesn’t shuffle the deck object; it returns a shuffled copy of the deck object:\nhead(deck, 3)\n##  face   suit value\n##  nine spades     9\n## eight spades     8\n## seven spades     7\n\na <- shuffle(deck)\n\nhead(deck, 3)\n##  face   suit value\n##  nine spades     9\n## eight spades     8\n## seven spades     7\n\nhead(a, 3)\n##  face     suit value\n##   ace diamonds     1\n## seven    clubs     7\n##   two    clubs     2\nThis behavior is now undesirable in two ways. First, shuffle fails to shuffle deck. Second, shuffle returns a copy of deck, which may be missing the cards that have been dealt away. It would be better if shuffle returned the dealt cards to the deck and then shuffled. This is what happens when you shuffle a deck of cards in real life.\n\n\n\n\n\n\nExercise: Rewrite shuffle\n\n\n\nRewrite shuffle so that it replaces the copy of deck that lives in the global environment with a shuffled version of DECK, the intact copy of deck that also lives in the global environment. The new version of shuffle should have no arguments and return no output.\n\n\nYou can update shuffle in the same way that you updated deck. The following version will do the job:\nshuffle <- function(){\n  random <- sample(1:52, size = 52)\n  assign(\"deck\", DECK[random, ], envir = globalenv())\n}\nSince DECK lives in the global environment, shuffle’s environment of origin, shuffle will be able to find DECK at runtime. R will search for DECK first in shuffle’s runtime environment, and then in shuffle’s origin environment—the global environment—which is where DECK is stored.\nThe second line of shuffle will create a reordered copy of DECK and save it as deck in the global environment. This will overwrite the previous, nonshuffled version of deck."
  },
  {
    "objectID": "environments.html#closures",
    "href": "environments.html#closures",
    "title": "9  Environments",
    "section": "9.6 Closures",
    "text": "9.6 Closures\nOur system finally works. For example, you can shuffle the cards and then deal a hand of blackjack:\nshuffle()\n\ndeal()\n##  face   suit value\n## queen hearts    12\n\ndeal()\n##  face   suit value\n## eight hearts     8\nBut the system requires deck and DECK to exist in the global environment. Lots of things happen in this environment, and it is possible that deck may get modified or erased by accident.\nIt would be better if we could store deck in a safe, out-of-the-way place, like one of those safe, out-of-the-way environments that R creates to run functions in. In fact, storing deck in a runtime environment is not such a bad idea.\nYou could create a function that takes deck as an argument and saves a copy of deck as DECK. The function could also save its own copies of deal and shuffle:\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = globalenv())\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = globalenv())\n }\n}\nWhen you run setup, R will create a runtime environment to store these objects in. The environment will look like Figure 9.7.\nNow all of these things are safely out of the way in a child of the global environment. That makes them safe but hard to use. Let’s ask setup to return DEAL and SHUFFLE so we can use them. The best way to do this is to return the functions as a list:\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = globalenv())\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = globalenv())\n }\n\n list(deal = DEAL, shuffle = SHUFFLE)\n}\n\ncards <- setup(deck)\n\n\n\nFigure 9.7: Running setup will store deck and DECK in an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of these objects will be stored in an environment whose parent is the global environment.\n\n\nThen you can save each of the elements of the list to a dedicated object in the global environment:\ndeal <- cards$deal\nshuffle <- cards$shuffle\nNow you can run deal and shuffle just as before. Each object contains the same code as the original deal and shuffle:\ndeal\n## function() {\n##     card <- deck[1, ]\n##     assign(\"deck\", deck[-1, ], envir = globalenv())\n##     card\n##   }\n## <environment: 0x7ff7169c3390>\n\nshuffle\n## function(){\n##     random <- sample(1:52, size = 52)\n##     assign(\"deck\", DECK[random, ], envir = globalenv())\n##  }\n## <environment: 0x7ff7169c3390>\nHowever, the functions now have one important difference. Their origin environment is no longer the global environment (although deal and shuffle are currently saved there). Their origin environment is the runtime environment that R made when you ran setup. That’s where R created DEAL and SHUFFLE, the functions copied into the new deal and shuffle, as shown in:\nenvironment(deal)\n## <environment: 0x7ff7169c3390>\n\nenvironment(shuffle)\n## <environment: 0x7ff7169c3390>\nWhy does this matter? Because now when you run deal or shuffle, R will evaluate the functions in a runtime environment that uses 0x7ff7169c3390 as its parent. DECK and deck will be in this parent environment, which means that deal and shuffle will be able to find them at runtime. DECK and deck will be in the functions’ search path but still out of the way in every other respect, as shown in Figure 9.8.\n\n\n\nFigure 9.8: Now deal and shuffle will be run in an environment that has the protected deck and DECK in its search path.\n\n\nThis arrangement is called a closure. setup’s runtime environment “encloses” the deal and shuffle functions. Both deal and shuffle can work closely with the objects contained in the enclosing environment, but almost nothing else can. The enclosing environment is not on the search path for any other R function or environment.\nYou may have noticed that deal and shuffle still update the deck object in the global environment. Don’t worry, we’re about to change that. We want deal and shuffle to work exclusively with the objects in the parent (enclosing) environment of their runtime environments. Instead of having each function reference the global environment to update deck, you can have them reference their parent environment at runtime, as shown in Figure 9.9:\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = parent.env(environment()))\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = parent.env(environment()))\n }\n\n list(deal = DEAL, shuffle = SHUFFLE)\n}\n\ncards <- setup(deck)\ndeal <- cards$deal\nshuffle <- cards$shuffle\n\n\n\nFigure 9.9: When you change your code, deal and shuffle will go from updating the global environment (left) to updating their parent environment (right).\n\n\nWe finally have a self-contained card game. You can delete (or modify) the global copy of deck as much as you want and still play cards. deal and shuffle will use the pristine, protected copy of deck:\nrm(deck)\n\nshuffle()\n\ndeal()\n## face   suit value\n##  ace hearts     1\n\ndeal()\n## face  suit value\n## jack clubs    11\nBlackjack!"
  },
  {
    "objectID": "environments.html#summary",
    "href": "environments.html#summary",
    "title": "9  Environments",
    "section": "9.7 Summary",
    "text": "9.7 Summary\nR saves its objects in an environment system that resembles your computer’s file system. If you understand this system, you can predict how R will look up objects. If you call an object at the command line, R will look for the object in the global environment and then the parents of the global environment, working its way up the environment tree one environment at a time.\nR will use a slightly different search path when you call an object from inside of a function. When you run a function, R creates a new environment to execute commands in. This environment will be a child of the environment where the function was originally defined. This may be the global environment, but it also may not be. You can use this behavior to create closures, which are functions linked to objects in protected environments.\nAs you become familiar with R’s environment system, you can use it to produce elegant results, like we did here. However, the real value of understanding the environment system comes from knowing how R functions do their job. You can use this knowledge to figure out what is going wrong when a function does not perform as expected."
  },
  {
    "objectID": "environments.html#project-2-wrap-up",
    "href": "environments.html#project-2-wrap-up",
    "title": "9  Environments",
    "section": "9.8 Project 2 Wrap-up",
    "text": "9.8 Project 2 Wrap-up\nYou now have full control over the data sets and values that you load into R. You can store data as R objects, you can retrieve and manipulate data values at will, and you can even predict how R will store and look up your objects in your computer’s memory.\nYou may not realize it yet, but your expertise makes you a powerful, computer-augmented data user. You can use R to save and work with larger data sets than you could otherwise handle. So far we’ve only worked with deck, a small data set; but you can use the same techniques to work with any data set that fits in your computer’s memory.\nHowever, storing data is not the only logistical task that you will face as a data scientist. You will often want to do tasks with your data that are so complex or repetitive that they are difficult to do without a computer. Some of the things can be done with functions that already exist in R and its packages, but others cannot. You will be the most versatile as a data scientist if you can write your own programs for computers to follow. R can help you do this. When you are ready, Project 3: Slot Machine will teach you the most useful skills for writing programs in R."
  },
  {
    "objectID": "thesis.html",
    "href": "thesis.html",
    "title": "Thesis: Daily Progress",
    "section": "",
    "text": "I commit to writting thesis daily."
  },
  {
    "objectID": "july04.html",
    "href": "july04.html",
    "title": "10  July 03,2022",
    "section": "",
    "text": "Structure of the PhD thesis to set the boll rolling\nSearch and collect materials that will help me to write the PhD thesis such as books and advices.\n\n\n10.0.1 Books for PhD Advice\n\nAuthoring a PhD Thesis: How to Plan, Draft, Write and Finish a Doctoral Dissertation 3rd Edition\nWriting Your Dissertation in Fifteen Minutes a Day: A Guide to Starting, Revising, and Finishing Your Doctoral Thesis\nThe Literature Review: Six Steps to Success Third Edition\nThe Craft of Research, Fourth Edition (Chicago Guides to Writing, Editing, and Publishing) Fourth Edition\n\n\nAs a PhD student, I had written dozens and dozens of research papers before reading this book. I wish now that I could redo them. The information presented in this book is clear and thorough. Even on my first skim of the book I have learned valuable skills that will improve my writing!! I only wish my undergrad professors had forced me to read this book previously!!\n\n\nIt’s still the best, esp. for new or returning graduate students, or for new faculty who teach grad classes or work in a research lab. It’s very clear without dumbing down the information, and does an excellent job of putting research questions in context. I still refer my grad students to the first chapters, esp. because the author takes the reader by the hand through examples of how to construct a decent research question, from scope to validity. Hard to beat.\n\n\nMy university students adore this book. They all wish they were assigned it in their first year of college rather than their fourth year (when they have me).\n\nHow to Write a Lot: A Practical Guide to Productive Academic Writing (Paperback)\nOn Writing, by Stephen King\nStrunk and Whites’ The Elements of Style\n\n\n\n\n\n10.0.2 Blog for PhD Advice\nCollections of Advise I have collected from multiple sources\n\nAs a PhD Examiner … My Top 25 Tips for PhD students\nFind good and best PhD thesis related to your field of study. You can find PhD Thesis on PhDThesis.org. Read through the thesis see how the thesis are structured. From there you can make your own structure too.\nJust Start Writing: No better time than now. Just start writting.\nMake a Schedule : Try to make schedule for each chapter and work toward completing it. Also, determine how many pages the chapter may take\nWrite the Introductions Last: Skip introduction since it will change after completing the chapters.\nMove Around : Dont stick on one chapter, if you are stuck, move to another chapter or section\nGet Feedback Early : Give supervisor draft for each chapter and get feedback early. Dont wait until the end to get feedback for the complete thesis. Give your supervisor enough time to read your thesis. Believe me they are busy, so agree a timescale with them.\nWhen you write a section leave it for a couple of days, then come back and edit it. This will help you to see mistakes more easily, with fresh eyes. You can repeat this process several times until you can’t find any more mistakes. Then, it’s time to give your thesis to somebody else to proofread.\nStart the document in style. Formatting the document from the start will make it easier at editing time1.\n\n\nReferences: Read your references one more time. Sometimes the reference management software makes mistakes.\nIf there’s research or analysis still to do, prioritize this over writing\nPreparation : Get rid of distractions (chats, emails, etc.).2\n\n\nTargets and consistency : Set a target and be consistent to that target (e.g., number of words to write). Dont be disappointed if you miss the target. “Set your target as something you know you can achieve daily, then beat it. Don’t set it as high as you can possibly imagine. I had a daily minimum target of 500 words, which I knew I could meet even on the least productive days. This meant that because I smashed the target most days, I finished every day feeling good about my progress, which in turn meant I started the next day feeling confident”3\nRoutine : Leave something easy that you will start next day at the end of each day. Close your computer browsers and clean your desk. This makes it easy for you to pick up next day.4\n\n\n10 tips for writing a PhD thesis\n\n\n\n10.0.3 Video for PhD Advice\n\n\n\n\n\n\nSailing Through Your PhD Thesis: Writing Tips↩︎\nHow I wrote a PhD thesis in 3 months↩︎\nHow I wrote a PhD thesis in 3 months↩︎\nHow I wrote a PhD thesis in 3 months↩︎"
  },
  {
    "objectID": "july05.html",
    "href": "july05.html",
    "title": "11  Programs",
    "section": "",
    "text": "In this chapter, you will build a real, working slot machine that you can play by running an R function. When you’re finished, you’ll be able to play it like this:\nThe play function will need to do two things. First, it will need to randomly generate three symbols; and, second, it will need to calculate a prize based on those symbols.\nThe first step is easy to simulate. You can randomly generate three symbols with the sample function—just like you randomly “rolled” two dice in Project 1: Weighted Dice. The following function generates three symbols from a group of common slot machine symbols: diamonds (DD), sevens (7), triple bars (BBB), double bars (BB), single bars (B), cherries (C), and zeroes (0). The symbols are selected randomly, and each symbol appears with a different probability:\nYou can use get_symbols to generate the symbols used in your slot machine:\nget_symbols uses the probabilities observed in a group of video lottery terminals from Manitoba, Canada. These slot machines became briefly controversial in the 1990s, when a reporter decided to test their payout rate. The machines appeared to pay out only 40 cents on the dollar, even though the manufacturer claimed they would pay out 92 cents on the dollar. The original data collected on the machines and a description of the controversy is available online in a journal article by W. John Braun. The controversy died down when additional testing showed that the manufacturer was correct.\nThe Manitoba slot machines use the complicated payout scheme shown in Table 11.1. A player will win a prize if he gets:\nOtherwise, the player receives no prize.\nThe monetary value of the prize is determined by the exact combination of symbols and is further modified by the presence of diamonds. Diamonds are treated like “wild cards,” which means they can be considered any other symbol if it would increase a player’s prize. For example, a player who rolls 7 7 DD would earn a prize for getting three sevens. There is one exception to this rule, however: a diamond cannot be considered a cherry unless the player also gets one real cherry. This prevents a dud roll like, 0 DD 0 from being scored as 0 C 0.\nDiamonds are also special in another way. Every diamond that appears in a combination doubles the amount of the final prize. So 7 7 DD would actually be scored higher than 7 7 7. Three sevens would earn you $80, but two sevens and a diamond would earn you $160. One seven and two diamonds would be even better, resulting in a prize that has been doubled twice, or $320. A jackpot occurs when a player rolls DD DD DD. Then a player earns $100 doubled three times, which is $800.\nTo create your play function, you will need to write a program that can take the output of get_symbols and calculate the correct prize based on Table 11.1.\nIn R, programs are saved either as R scripts or as functions. We’ll save your program as a function named score. When you are finished, you will be able to use score to calculate a prize like this:\nAfter that it will be easy to create the full slot machine, like this:\nYou may notice that play calls a new function, print. This will help play display the three slot machine symbols, since they do not get returned by the last line of the function. The print command prints its output to the console window – even if R calls it from within a function.\nIn Project 1: Weighted Dice, I encouraged you to write all of your R code in an R script, a text file where you can compose and save code. That advice will become very important as you work through this chapter. Remember that you can open an R script in RStudio by going to the menu bar and clicking on File > New File > R Script."
  },
  {
    "objectID": "july05.html#strategy",
    "href": "july05.html#strategy",
    "title": "11  Programs",
    "section": "11.1 Strategy",
    "text": "11.1 Strategy\nScoring slot-machine results is a complex task that will require a complex algorithm. You can make this, and other coding tasks, easier by using a simple strategy:\n\nBreak complex tasks into simple subtasks.\nUse concrete examples.\nDescribe your solutions in English, then convert them to R.\n\nLet’s start by looking at how you can divide a program into subtasks that are simple to work with.\nA program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward.\nYou can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function.\nR programs contain two types of subtasks: sequential steps and parallel cases.\n\n11.1.1 Sequential Steps\nOne way to subdivide a program is into a series of sequential steps. The play function takes the approach, shown in Figure 11.1. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3):\nplay <- function() {\n\n  # step 1: generate symbols\n  symbols <- get_symbols()\n\n  # step 2: display the symbols\n  print(symbols)\n\n  # step 3: score the symbols\n  score(symbols)\n}\nTo have R execute steps in sequence, place the steps one after another in an R script or function body.\n\n\n\nFigure 11.1: The play function uses a series of steps.\n\n\n\n\n11.1.2 Parallel Cases\nAnother way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time.\nFor example, score will need to calculate the prize one way if symbols contains three of a kind (In that case, score will need to match the common symbol to a prize). score will need to calculate the prize a second way if the symbols are all bars (In that case, score can just assign a prize of $5). And, finally, score will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, score must count the number of cherries present). score will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols.\nDiamonds complicate all of this because diamonds can be treated as wild cards. Let’s ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. score can double the prize as necessary after it runs one of the following algorithms, as shown in Figure 11.2.\nAdding the score cases to the play steps reveals a strategy for the complete slot machine program, as shown in Figure 11.3.\nWe’ve already solved the first few steps in this strategy. Our program can get three slot machine symbols with the get_symbols function. Then it can display the symbols with the print function. Now let’s examine how the program can handle the parallel score cases.\n\n\n\nFigure 11.2: The score function must distinguish between parallel cases.\n\n\n\n\n\nFigure 11.3: The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel."
  },
  {
    "objectID": "july05.html#if-statements",
    "href": "july05.html#if-statements",
    "title": "11  Programs",
    "section": "11.2 if Statements",
    "text": "11.2 if Statements\nLinking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an if statement.\nAn if statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say:\nif (this) {\n  that\n}\nThe this object should be a logical test or an R expression that evaluates to a single TRUE or FALSE. If this evaluates to TRUE, R will run all of the code that appears between the braces that follow the if statement (i.e., between the { and } symbols). If this evaluates to FALSE, R will skip the code between the braces without running it.\nFor example, you could write an if statement that ensures some object, num, is positive:\nif (num < 0) {\n  num <- num * -1\n}\nIf num < 0 is TRUE, R will multiply num by negative one, which will make num positive:\nnum <- -2\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 2\nIf num < 0 is FALSE, R will do nothing and num will remain as it is—positive (or zero):\nnum <- 4\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 4\nThe condition of an if statement must evaluate to a single TRUE or FALSE. If the condition creates a vector of TRUEs and FALSEs (which is easier to make than you may think), your if statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single TRUE or FALSE with the functions any and all.\nYou don’t have to limit your if statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that num is positive. The additional lines print some informative statements if num begins as a negative number. R will skip the entire code block—print statements and all—if num begins as a positive number:\nnum <- -1\n\nif (num < 0) {\n  print(\"num is negative.\")\n  print(\"Don't worry, I'll fix it.\")\n  num <- num * -1\n  print(\"Now num is positive.\")\n}\n## \"num is negative.\"\n## \"Don't worry, I'll fix it.\"\n## \"Now num is positive.\"\n\nnum\n## 1\nTry the following quizzes to develop your understanding of if statements.\n\n\n\n\n\n\nExercise: Quiz A\n\n\n\nWhat will this return?\nx <- 1\nif (3 == 3) {\n  x <- 2\n}\nx\n\n\nThe code will return the number 2. x begins as 1, and then R encounters the if statement. Since the condition evaluates to TRUE, R will run x <- 2, changing the value of x.\n\n\n\n\n\n\nExercise: Quiz B\n\n\n\nWhat will this return?\n```r\nx <- 1\nif (TRUE) {\n  x <- 2\n}\nx\n\n\nThis code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already TRUE. R doesn’t even need to evaluate it. As a result, the code inside the if statement will be run, and x will be set to 2.\n\n\n\n\n\n\nExercise: Quiz C\n\n\n\nWhat will this return?\nx <- 1\nif (x == 1) {\n  x <- 2\n  if (x == 1) {\n    x <- 3\n  }\n}\nx\n\n\nOnce again, the code will return the number 2. x starts out as 1, and the condition of the first if statement will evaluate to TRUE, which causes R to run the code in the body of the if statement. First, R sets x equal to 2, then R evaluates the second if statement, which is in the body of the first. This time x == 1 will evaluate to FALSE because x now equals 2. As a result, R ignores x <- 3 and exits both if statements."
  },
  {
    "objectID": "july05.html#else-statements",
    "href": "july05.html#else-statements",
    "title": "11  Programs",
    "section": "11.3 else Statements",
    "text": "11.3 else Statements\nif statements tell R what to do when your condition is true, but you can also tell R what to do when the condition is false. else is a counterpart to if that extends an if statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” In R, you would say:\nif (this) {\n  Plan A\n} else {\n  Plan B\n}\nWhen this evaluates to TRUE, R will run the code in the first set of braces, but not the code in the second. When this evaluates to FALSE, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer.\nStart with a decimal:\na <- 3.14\nThen isolate the decimal component with trunc:\ndec <- a - trunc(a)\ndec\n## 0.14\n\n\n\n\n\n\nNote\n\n\n\ntrunc takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number).\n\n\n\n\n\n\n\n\nNote\n\n\n\na - trunc(a) is a convenient way to return the decimal part of a.\n\n\nThen use an if else tree to round the number (either up or down):\nif (dec >= 0.5) {\n  a <- trunc(a) + 1\n} else {\n  a <- trunc(a)\n}\n\na\n## 3\nIf your situation has more than two mutually exclusive cases, you can string multiple if and else statements together by adding a new if statement immediately after else. For example:\na <- 1\nb <- 1\n\nif (a > b) {\n  print(\"A wins!\")\n} else if (a < b) {\n  print(\"B wins!\")\n} else {\n  print(\"Tie.\")\n}\n## \"Tie.\"\nR will work through the if conditions until one evaluates to TRUE, then R will ignore any remaining if and else clauses in the tree. If no conditions evaluate to TRUE, R will run the final else statement.\nIf two if statements describe mutually exclusive events, it is better to join the if statements with an else if than to list them separately. This lets R ignore the second if statement whenever the first returns a TRUE, which saves work.\nYou can use if and else to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final score function. Compare it to the flow chart for score in Figure 11.2:\nif ( # Case 1: all the same <1>) {\n  prize <- # look up the prize <3>\n} else if ( # Case 2: all bars <2> ) {\n  prize <- # assign $5 <4>\n} else {\n  # count cherries <5>\n  prize <- # calculate a prize <7>\n}\n\n# count diamonds <6>\n# double the prize if necessary <8>\nOur skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we’ve reduced the program to eight simple subtasks:\n<1> - Test whether the symbols are three of a kind.\n<2> - Test whether the symbols are all bars.\n<3> - Look up the prize for three of a kind based on the common symbol.\n<4> - Assign a prize of $5.\n<5> - Count the number of cherries.\n<6> - Count the number of diamonds.\n<7> - Calculate a prize based on the number of cherries.\n<8> - Adjust the prize for diamonds.\nIf you like, you can reorganize your flow chart around these tasks, as in Figure 11.4. The chart will describe the same strategy, but in a more precise way. I’ll use a diamond shape to symbolize an if else decision.\n\n\n\nFigure 11.4: score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.\n\n\nNow we can work through the subtasks one at a time, adding R code to the if tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R.\nThe first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask?\nYou know that the final score function will look something like this:\nscore <- function(symbols) {\n\n  # calculate a prize\n\n  prize\n}\nIts argument, symbols, will be the output of get_symbols, a vector that contains three character strings. You could start writing score as I have written it, by defining an object named score and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until all of those parts are written (and themselves work correctly). This means you would have to write the entire score function before you could test any of the subtasks. If score doesn’t work—which is very likely—you will not know which subtask needs fixed.\nYou can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on. For example, you know that score will need to work on a vector named symbols that contains three character strings. If you make a real vector named symbols, you can run the code for many of your subtasks on the vector as you go:\nsymbols <- c(\"7\", \"7\", \"7\")\nIf a piece of code does not work on symbols, you will know that you need to fix it before you move on. You can change the value of symbols from subtask to subtask to ensure that your code works in every situation:\nsymbols <- c(\"B\", \"BB\", \"BBB\")\nsymbols <- c(\"C\", \"DD\", \"0\")\nOnly combine your subtasks into a score function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work.\nAfter you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code.\nOur first subtask asks us to “test whether the symbols are three of a kind.” This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely:\nA vector named symbols will contain three of the same symbol if the first element of symbols is equal to the second element of symbols and the second element of symbols is equal to the third element of symbols.\n\n\n\n\n\n\nExercise: Write a Test\n\n\n\nTurn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from R Notation. The test should work with the vector symbols and return a TRUE if and only if each element in symbols is the same. Be sure to test your code on symbols.\n\n\nHere are a couple of ways to test that symbols contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you’ve created a vector named symbols:\nsymbols\n##  \"7\" \"7\" \"7\"\n\nsymbols[1] == symbols[2] & symbols[2] == symbols[3]\n## TRUE\n\nsymbols[1] == symbols[2] & symbols[1] == symbols[3]\n## TRUE\n\nall(symbols == symbols[1])\n## TRUE\nAs your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is:\nlength(unique(symbols) == 1)\nThe unique function returns every unique term that appears in a vector. If your symbols vector contains three of a kind (i.e., one unique term that appears three times), then unique(symbols) will return a vector of length 1.\nNow that you have a working test, you can add it to your slot-machine script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n\nif (same) {\n  prize <- # look up the prize\n} else if ( # Case 2: all bars ) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n\n\n\n\n\n\nNote\n\n\n\n&& and || behave like & and | but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if symbols[1] does not equal symbols[2] in the next expression, && will not evaluate symbols[2] == symbols[3]; it can immediately return a FALSE for the whole expression (because FALSE & TRUE and FALSE & FALSE both evaluate to FALSE). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. && and || are not vectorized, which means they can only handle a single logical test on each side of the operator.\n\n\nThe second prize case occurs when all the symbols are a type of bar, for example, B, BB, and BBB. Let’s begin by creating a concrete example to work with:\nsymbols <- c(\"B\", \"BBB\", \"BB\")\n\n\n\n\n\n\nExercise: Test for All Bars\n\n\n\nUse R’s logical and Boolean operators to write a test that will determine whether a vector named symbols contains only symbols that are a type of bar. Check whether your test works with our example symbols vector. Remember to describe how the test should work in English, and then convert the solution to R.\n\n\nAs with many things in R, there are multiple ways to test whether symbols contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this:\n(symbols[1] == \"B\" | symbols[1] == \"BB\" | symbols[1] == \"BBB\") &\n  (symbols[2] == \"B\" | symbols[2] == \"BB\" | symbols[2] == \"BBB\") &\n  (symbols[3] == \"B\" | symbols[3] == \"BB\" | symbols[3] == \"BBB\")\n## TRUE\nHowever, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple | operators with a single %in%. Also, you can check that a test is true for each element in a vector with all. These two changes shorten the preceding code to:\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nLet’s add this code to our script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  prize <- # look up the prize\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nYou may have noticed that I split this test up into two steps, bars and all(bars). That’s just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do.\nYou also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind:\nsymbols <- c(\"B\", \"B\", \"B\")\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nThat won’t be a problem, however, because we’ve connected our cases with else if in the if tree. As soon as R comes to a case that evaluates to TRUE, it will skip over the rest of the tree. Think of it this way: each else tells R to only run the code that follows it if none of the previous conditions have been met. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3).\nOur next subtask is to assign a prize for symbols. When the symbols vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three DDs, the prize will be $100; if there are three 7s, the prize will be $80; and so on.\nThis suggests another if tree. You could assign a prize with some code like this:\nif (same) {\n  symbol <- symbols[1]\n  if (symbol == \"DD\") {\n    prize <- 800\n  } else if (symbol == \"7\") {\n    prize <- 80\n  } else if (symbol == \"BBB\") {\n    prize <- 40\n  } else if (symbol == \"BB\") {\n    prize <- 5\n  } else if (symbol == \"B\") {\n    prize <- 10\n  } else if (symbol == \"C\") {\n    prize <- 10\n  } else if (symbol == \"0\") {\n    prize <- 0\n  }\n}\nWhile this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method."
  },
  {
    "objectID": "july05.html#lookup-tables",
    "href": "july05.html#lookup-tables",
    "title": "11  Programs",
    "section": "11.4 Lookup Tables",
    "text": "11.4 Lookup Tables\nVery often in R, the simplest way to do something will involve subsetting. How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements:\npayouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n  \"B\" = 10, \"C\" = 10, \"0\" = 0)\npayouts\n##  DD   7 BBB  BB   B   C   0 \n## 100  80  40  25  10  10   0 \nNow you can extract the correct prize for any symbol by subsetting the vector with the symbol’s name:\npayouts[\"DD\"]\n##  DD \n## 100 \n\npayouts[\"B\"]\n##  B\n## 10\nIf you want to leave behind the symbol’s name when subsetting, you can run the unname function on the output:\nunname(payouts[\"DD\"])\n## 100 \nunname returns a copy of an object with the names attribute removed.\npayouts is a type of lookup table, an R object that you can use to look up values. Subsetting payouts provides a simple way to find the prize for a symbol. It doesn’t take many lines of code, and it does the same amount of work whether your symbol is DD or 0. You can create lookup tables in R by creating named objects that can be subsetted in clever ways.\nSadly, our method is not quite automatic; we need to tell R which symbol to look up in payouts. Or do we? What would happen if you subsetted payouts by symbols[1]? Give it a try:\nsymbols <- c(\"7\", \"7\", \"7\")\nsymbols[1]\n## \"7\"\n\npayouts[symbols[1]]\n##  7 \n## 80 \n\nsymbols <- c(\"C\", \"C\", \"C\")\npayouts[symbols[1]]\n##  C \n## 10 \nYou don’t need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in symbols. You can find this symbol with symbols[1], symbols[2], or symbols[3], because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when symbols contains three of a kind. Let’s add it to our code and then look at Case 2:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nCase 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nNow we can work on the last case. Here, you’ll need to know how many cherries are in symbols before you can calculate a prize.\n\n\n\n\n\n\nExercise: Find C’s\n\n\n\nHow can you tell which elements of a vector named symbols are a C? Devise a test and try it out.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow might you count the number of Cs in a vector named symbols? Remember R’s coercion rules.\n\n\nAs always, let’s work with a real example:\nsymbols <- c(\"C\", \"DD\", \"C\")\nOne way to test for cherries would be to check which, if any, of the symbols are a C:\nsymbols == \"C\"\n## TRUE FALSE  TRUE\nIt’d be even more useful to count how many of the symbols are cherries. You can do this with sum, which expects numeric input, not logical. Knowing this, R will coerce the TRUEs and FALSEs to 1s and 0s before doing the summation. As a result, sum will return the number of TRUEs, which is also the number of cherries:\nsum(symbols == \"C\")\n## 2\nYou can use the same method to count the number of diamonds in symbols:\nsum(symbols == \"DD\")\n## 1\nLet’s add both of these subtasks to the program skeleton:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- # calculate a prize\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\nSince Case 3 appears further down the if tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine’s payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don’t need to worry about three cherries because that outcome is already covered in Case 1.\nAs in Case 1, you could write an if tree that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution:\nif (cherries == 2) {\n  prize <- 5\n} else if (cherries == 1) {\n  prize <- 2\n} else {}\n  prize <- 0\n}\nAgain, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution.\nWe know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table:\nc(0, 2, 5)\nNow, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize’s aren’t identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in cherries. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, c(0, 2, 5)[1].\ncherries isn’t exactly suited for integer subsetting because it could contain a zero, but that’s easy to fix. We can subset with cherries + 1. Now when cherries equals zero, we have:\ncherries + 1\n## 1\n\nc(0, 2, 5)[cherries + 1]\n## 0\nWhen cherries equals one, we have:\ncherries + 1\n## 2\n\nc(0, 2, 5)[cherries + 1]\n## 2\nAnd when cherries equals two, we have:\ncherries + 1\n## 3\n\nc(0, 2, 5)[cherries + 1]\n## 5\nExamine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\n\n\n\n\n\n\nLookup Tables Versus if Trees\n\n\n\nThis is the second time we’ve created a lookup table to avoid writing an if tree. Why is this technique helpful and why does it keep appearing? Many if trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, if trees are not appropriate everywhere.\nif trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the if tree, which can create unnecessary work. Second, as you’ll see in Speed, it can be difficult to use if trees in vectorized code, a style of code that takes advantage of R’s programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks.\nYou won’t be able to replace every if tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with if trees. As a general rule, use an if tree if each branch of the tree runs different code. Use a lookup table if each branch of the tree only assigns a different value.\nTo convert an if tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the if tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting.\n\n\nThe final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize. For example, if no diamonds are present, the prize will be:\nprize * 1      # 1 = 2 ^ 0\nIf one diamond is present, it will be:\nprize * 2      # 2 = 2 ^ 1\nIf two diamonds are present, it will be:\nprize * 4      # 4 = 2 ^ 2\nAnd if three diamonds are present, it will be:\nprize * 8      # 8 = 2 ^ 3\nCan you think of an easy way to handle this? How about something similar to these examples?\n\n\n\n\n\n\nExercise: Adjust for Diamonds\n\n\n\nWrite a method for adjusting prize based on diamonds. Describe a solution in English first, and then write your code.\n\n\nHere is a concise solution inspired by the previous pattern. The adjusted prize will equal:\nprize * 2 ^ diamonds\nwhich gives us our final score script:\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds"
  },
  {
    "objectID": "july05.html#code-comments",
    "href": "july05.html#code-comments",
    "title": "11  Programs",
    "section": "11.5 Code Comments",
    "text": "11.5 Code Comments\nYou now have a working score script that you can save to a function. Before you save your script, though, consider adding comments to your code with a #. Comments can make your code easier to understand by explaining why the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the score code:\n# identify case\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\n# get prize\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\n# adjust for diamonds\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds\nNow that each part of your code works, you can wrap it into a function with the methods you learned in Writing Your Own Functions. Either use RStudio’s Extract Function option in the menu bar under Code, or use the function function. Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like symbols, will become the arguments of your function. Run the following code to start using the score function:\nscore <- function (symbols) {\n  # identify case\n  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n  bars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # get prize\n  if (same) {\n    payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    prize <- unname(payouts[symbols[1]])\n  } else if (all(bars)) {\n    prize <- 5\n  } else {\n    cherries <- sum(symbols == \"C\")\n    prize <- c(0, 2, 5)[cherries + 1]\n  }\n  \n  # adjust for diamonds\n  diamonds <- sum(symbols == \"DD\")\n  prize * 2 ^ diamonds\n}\nOnce you have defined the score function, the play function will work as well:\nplay <- function() {\n  symbols <- get_symbols()\n  print(symbols)\n  score(symbols)\n}\nNow it is easy to play the slot machine:\nplay()\n## \"0\"  \"BB\" \"B\" \n## 0\n\nplay()\n## \"DD\"  \"0\" \"B\"  \n## 0\n\nplay()\n## \"BB\" \"BB\" \"B\" \n## 25"
  },
  {
    "objectID": "july05.html#summary",
    "href": "july05.html#summary",
    "title": "11  Programs",
    "section": "11.6 Summary",
    "text": "11.6 Summary\nAn R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don’t be fooled: you can create complicated results with the right combination of simple steps (and cases).\nAs a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse.\nR provides tools that can help you do this. You can manage cases with if and else statements. You can create a lookup table with objects and subsetting. You can add code comments with #. And you can save your programs as a function with function.\nThings often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time. However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R’s built in debugging tools, described in Debugging R Code.\nThe next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In S3, you will learn how to use R’s S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class."
  },
  {
    "objectID": "a1-starting.html",
    "href": "a1-starting.html",
    "title": "Appendix A — Installing R and RStudio",
    "section": "",
    "text": "To get started with R, you need to acquire your own copy. This appendix will show you how to download R as well as RStudio, a software application that makes R easier to use. You’ll go from downloading R to opening your first R session.\nBoth R and RStudio are free and easy to download."
  },
  {
    "objectID": "a1-starting.html#how-to-download-and-install-r",
    "href": "a1-starting.html#how-to-download-and-install-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.1 How to Download and Install R",
    "text": "A.1 How to Download and Install R\nR is maintained by an international team of developers who make the language available through the web page of The Comprehensive R Archive Network. The top of the web page provides three links for downloading R. Follow the link that describes your operating system: Windows, Mac, or Linux.\n\nA.1.1 Windows\nTo install R on Windows, click the “Download R for Windows” link. Then click the “base” link. Next, click the first link at the top of the new page. This link should say something like “Download R 3.0.3 for Windows,” except the 3.0.3 will be replaced by the most current version of R. The link downloads an installer program, which installs the most up-to-date version of R for Windows. Run this program and step through the installation wizard that appears. The wizard will install R into your program files folders and place a shortcut in your Start menu. Note that you’ll need to have all of the appropriate administration privileges to install new software on your machine.\n\n\nA.1.2 Mac\nTo install R on a Mac, click the “Download R for Mac” link. Next, click on the R-3.0.3 package link (or the package link for the most current release of R). An installer will download to guide you through the installation process, which is very easy. The installer lets you customize your installation, but the defaults will be suitable for most users. I’ve never found a reason to change them. If your computer requires a password before installing new progams, you’ll need it here.\n\n\n\n\n\n\nBinaries Versus Source\n\n\n\nR can be installed from precompiled binaries or built from source on any operating system. For Windows and Mac machines, installing R from binaries is extremely easy. The binary comes preloaded in its own installer. Although you can build R from source on these platforms, the process is much more complicated and won’t provide much benefit for most users. For Linux systems, the opposite is true. Precompiled binaries can be found for some systems, but it is much more common to build R from source files when installing on Linux. The download pages on CRAN’s website provide information about building R from source for the Windows, Mac, and Linux platforms.\n\n\n\n\nA.1.3 Linux\nR comes preinstalled on many Linux systems, but you’ll want the newest version of R if yours is out of date. The CRAN website provides files to build R from source on Debian, Redhat, SUSE, and Ubuntu systems under the link “Download R for Linux.” Click the link and then follow the directory trail to the version of Linux you wish to install on. The exact installation procedure will vary depending on the Linux system you use. CRAN guides the process by grouping each set of source files with documentation or README files that explain how to install on your system.\n\n\n\n\n\n\n32-bit Versus 64-bit\n\n\n\nR comes in both 32-bit and 64-bit versions. Which should you use? In most cases, it won’t matter. Both versions use 32-bit integers, which means they compute numbers to the same numerical precision. The difference occurs in the way each version manages memory. 64-bit R uses 64-bit memory pointers, and 32-bit R uses 32-bit memory pointers. This means 64-bit R has a larger memory space to use (and search through).\nAs a rule of thumb, 32-bit builds of R are faster than 64-bit builds, though not always. On the other hand, 64-bit builds can handle larger files and data sets with fewer memory management problems. In either version, the maximum allowable vector size tops out at around 2 billion elements. If your operating system doesn’t support 64-bit programs, or your RAM is less than 4 GB, 32-bit R is for you. The Windows and Mac installers will automatically install both versions if your system supports 64-bit R."
  },
  {
    "objectID": "a1-starting.html#using-r",
    "href": "a1-starting.html#using-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.2 Using R",
    "text": "A.2 Using R\nR isn’t a program that you can open and start using, like Microsoft Word or Internet Explorer. Instead, R is a computer language, like C, C++, or UNIX. You use R by writing commands in the R language and asking your computer to interpret them. In the old days, people ran R code in a UNIX terminal window—as if they were hackers in a movie from the 1980s. Now almost everyone uses R with an application called RStudio, and I recommend that you do, too.\n\n\n\n\n\n\nR and UNIX\n\n\n\nYou can still run R in a UNIX or BASH window by typing the command:\n$ R\nwhich opens an R interpreter. You can then do your work and close the interpreter by running q() when you are finished."
  },
  {
    "objectID": "a1-starting.html#rstudio",
    "href": "a1-starting.html#rstudio",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.3 RStudio",
    "text": "A.3 RStudio\nRStudio is an application like Microsoft Word—except that instead of helping you write in English, RStudio helps you write in R. I use RStudio throughout the book because it makes using R much easier. Also, the RStudio interface looks the same for Windows, Mac OS, and Linux. That will help me match the book to your personal experience.\nYou can download RStudio for free. Just click the “Download RStudio” button and follow the simple instructions that follow. Once you’ve installed RStudio, you can open it like any other program on your computer—usually by clicking an icon on your desktop.\n\n\n\n\n\n\nThe R GUIs\n\n\n\nWindows and Mac users usually do not program from a terminal window, so the Windows and Mac downloads for R come with a simple program that opens a terminal-like window for you to run R code in. This is what opens when you click the R icon on your Windows or Mac computer. These programs do a little more than the basic terminal window, but not much. You may hear people refer to them as the Windows or Mac R GUIs.\n\n\nWhen you open RStudio, a window appears with three panes in it, as in Figure A.1. The largest pane is a console window. This is where you’ll run your R code and see results. The console window is exactly what you’d see if you ran R from a UNIX console or the Windows or Mac GUIs. Everything else you see is unique to RStudio. Hidden in the other panes are a text editor, a graphics window, a debugger, a file manager, and much more. You’ll learn about these panes as they become useful throughout the course of this book.\n\n\n\nFigure A.1: The RStudio IDE for R.\n\n\n\n\n\n\n\n\nDo I still need to download R?\n\n\n\nEven if you use RStudio, you’ll still need to download R to your computer. RStudio helps you use the version of R that lives on your computer, but it doesn’t come with a version of R on its own."
  },
  {
    "objectID": "a1-starting.html#opening-r",
    "href": "a1-starting.html#opening-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.4 Opening R",
    "text": "A.4 Opening R\nNow that you have both R and RStudio on your computer, you can begin using R by opening the RStudio program. Open RStudio just as you would any program, by clicking on its icon or by typing “RStudio” at the Windows Run prompt."
  },
  {
    "objectID": "a2-packages.html",
    "href": "a2-packages.html",
    "title": "Appendix B — R Packages",
    "section": "",
    "text": "Many of R’s most useful functions do not come preloaded when you start R, but reside in packages that can be installed on top of R. R packages are similar to libraries in C, C++, and Javascript, packages in Python, and gems in Ruby. An R package bundles together useful functions, help files, and data sets. You can use these functions within your own R code once you load the package they live in. Usually the contents of an R package are all related to a single type of task, which the package helps solve. R packages will let you take advantage of R’s most useful features: its large community of package writers (many of whom are active data scientists) and its prewritten routines for handling many common (and exotic) data-science tasks."
  },
  {
    "objectID": "a2-packages.html#installing-packages",
    "href": "a2-packages.html#installing-packages",
    "title": "Appendix B — R Packages",
    "section": "B.1 Installing Packages",
    "text": "B.1 Installing Packages\nTo use an R package, you must first install it on your computer and then load it in your current R session. The easiest way to install an R package is with the install.packages R function. Open R and type the following into the command line:\ninstall.packages(\"<package name>\")\nThis will search for the specified package in the collection of packages hosted on the CRAN site. When R finds the package, it will download it into a libraries folder on your computer. R can access the package here in future R sessions without reinstalling it. Anyone can write an R package and disseminate it as they like; however, almost all R packages are published through the CRAN website. CRAN tests each R package before publishing it. This doesn’t eliminate every bug inside a package, but it does mean that you can trust a package on CRAN to run in the current version of R on your OS.\nYou can install multiple packages at once by linking their names with R’s concatenate function, c. For example, to install the ggplot2, reshape2, and dplyr packages, run:\ninstall.packages(c(\"ggplot2\", \"reshape2\", \"dplyr\"))\nIf this is your first time installing a package, R will prompt you to choose an online mirror of to install from. Mirrors are listed by location. Your downloads should be quickest if you select a mirror that is close to you. If you want to download a new package, try the Austria mirror first. This is the main CRAN repository, and new packages can sometimes take a couple of days to make it around to all of the other mirrors."
  },
  {
    "objectID": "a2-packages.html#loading-packages",
    "href": "a2-packages.html#loading-packages",
    "title": "Appendix B — R Packages",
    "section": "B.2 Loading Packages",
    "text": "B.2 Loading Packages\nInstalling a package doesn’t immediately place its functions at your fingertips. It just places them on your computer. To use an R package, you next have to load it in your R session with the command:\nlibrary(<package name>)\nNotice that the quotation marks have disappeared. You can use them if you like, but quotation marks are optional for the library command. (This is not true for the install.packages command).\nlibrary will make all of the package’s functions, data sets, and help files available to you until you close your current R session. The next time you begin an R session, you’ll have to reload the package with library if you want to use it, but you won’t have to reinstall it. You only have to install each package once. After that, a copy of the package will live in your R library. To see which packages you currently have in your R library, run:\nlibrary()\nlibrary() also shows the path to your actual R library, which is the folder that contains your R packages. You may notice many packages that you don’t remember installing. This is because R automatically downloads a set of useful packages when you first install R.\n\n\n\n\n\n\nInstall packages from (almost) anywhere\n\n\n\nThe devtools R package makes it easy to install packages from locations other than the CRAN website. devtools provides functions like install_github, install_gitorious, install_bitbucket, and install_url. These work similar to install.packages, but they search new locations for R packages. install_github is especially useful because many R developers provide development versions of their packages on GitHub. The development version of a package will contain a sneak peek of new functions and patches but may not be as stable or as bug free as the CRAN version.\n\n\nWhy does R make you bother with installing and loading packages? You can imagine an R where every package came preloaded, but this would be a very large and slow program. As of May 6, 2014, the CRAN website hosts 5,511 packages. It is simpler to only install and load the packages that you want to use when you want to use them. This keeps your copy of R fast because it has fewer functions and help pages to search through at any one time. The arrangement has other benefits as well. For example, it is possible to update your copy of an R package without updating your entire copy of R.\n\n\n\n\n\n\nWhat’s the best way to learn about R packages?\n\n\n\nIt is difficult to use an R package if you don’t know that it exists. You could go to the CRAN website and click the Packages link to see a list of available packages, but you’ll have to wade through thousands of them. Moreover, many R packages do the same things.\nHow do you know which package does them best? The R-packages mailing list is a place to start. It sends out announcements of new packages and maintains an archive of old announcements. Blogs that aggregate posts about R can also provide valuable leads. I recommend R-bloggers. RStudio maintains a list of some of the most useful R packages in the Getting Started section of http://support.rstudio.com. Finally, CRAN groups together some of the most useful—and most respected—packages by subject area. This is an excellent place to learn about the packages designed for your area of work."
  },
  {
    "objectID": "a3-updating.html",
    "href": "a3-updating.html",
    "title": "Appendix C — Updating R and Its Packages",
    "section": "",
    "text": "The R Core Development Team continuously hones the R language by catching bugs, improving performance, and updating R to work with new technologies. As a result, new versions of R are released several times a year. The easiest way to stay current with R is to periodically check the CRAN website. The website is updated for each new release and makes the release available for download. You’ll have to install the new release. The process is the same as when you first installed R.\nDon’t worry if you’re not interested in staying up-to-date on R Core’s doings. R changes only slightly between releases, and you’re not likely to notice the differences. However, updating to the current version of R is a good place to start if you ever encounter a bug that you can’t explain.\nRStudio also constantly improves its product. You can acquire the newest updates just by downloading them from RStudio."
  },
  {
    "objectID": "a3-updating.html#r-packages",
    "href": "a3-updating.html#r-packages",
    "title": "Appendix C — Updating R and Its Packages",
    "section": "C.1 R Packages",
    "text": "C.1 R Packages\nPackage authors occasionally release new versions of their packages to add functions, fix bugs, or improve performance. The update.packages command checks whether you have the most current version of a package and installs the most current version if you do not. The syntax for update.packages follows that of install.packages. If you already have ggplot2, reshape2, and dplyr on your computer, it’d be a good idea to check for updates before you use them:\nupdate.packages(c(\"ggplot2\", \"reshape2\", \"dplyr\"))\nYou should start a new R session after updating packages. If you have a package loaded when you update it, you’ll have to close your R session and open a new one to begin using the updated version of the package."
  },
  {
    "objectID": "a4-data.html",
    "href": "a4-data.html",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "",
    "text": "This appendix will show you how to load and save data into R from plain-text files, R files, and Excel spreadsheets. It will also show you the R packages that you can use to load data from databases and other common programs, like SAS and MATLAB."
  },
  {
    "objectID": "a4-data.html#data-sets-in-base-r",
    "href": "a4-data.html#data-sets-in-base-r",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.1 Data Sets in Base R",
    "text": "D.1 Data Sets in Base R\nR comes with many data sets preloaded in the datasets package, which comes with base R. These data sets are not very interesting, but they give you a chance to test code or make a point without having to load a data set from outside R. You can see a list of R’s data sets as well as a short description of each by running:\nhelp(package = \"datasets\")\nTo use a data set, just type its name. Each data set is already presaved as an R object. For example:\niris\n##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\n## 6          5.4         3.9          1.7         0.4  setosa\nHowever, R’s data sets are no substitute for your own data, which you can load into R from a wide variety of file formats. But before you load any data files into R, you’ll need to determine where your working directory is."
  },
  {
    "objectID": "a4-data.html#working-directory",
    "href": "a4-data.html#working-directory",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.2 Working Directory",
    "text": "D.2 Working Directory\nEach time you open R, it links itself to a directory on your computer, which R calls the working directory. This is where R will look for files when you attempt to load them, and it is where R will save files when you save them. The location of your working directory will vary on different computers. To determine which directory R is using as your working directory, run:\ngetwd()\n## \"/Users/garrettgrolemund\"\nYou can place data files straight into the folder that is your working directory, or you can move your working directory to where your data files are. You can move your working directory to any folder on your computer with the function setwd. Just give setwd the file path to your new working directory. I prefer to set my working directory to a folder dedicated to whichever project I am currently working on. That way I can keep all of my data, scripts, graphs, and reports in the same place. For example:\nsetwd(\"~/Users/garrettgrolemund/Documents/Book_Project\")\nIf the file path does not begin with your root directory, R will assume that it begins at your current working directory.\nYou can also change your working directory by clicking on Session > Set Working Directory > Choose Directory in the RStudio menu bar. The Windows and Mac GUIs have similar options. If you start R from a UNIX command line (as on Linux machines), the working directory will be whichever directory you were in when you called R.\nYou can see what files are in your working directory with list.files(). If you see the file that you would like to open in your working directory, then you are ready to proceed. How you open files in your working directory will depend on which type of file you would like to open."
  },
  {
    "objectID": "a4-data.html#plain-text-files",
    "href": "a4-data.html#plain-text-files",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.3 Plain-text Files",
    "text": "D.3 Plain-text Files\nPlain-text files are one of the most common ways to save data. They are very simple and can be read by many different computer programs—even the most basic text editors. For this reason, public data often comes as plain-text files. For example, the Census Bureau, the Social Security Administration, and the Bureau of Labor Statistics all make their data available as plain-text files.\nHere’s how the royal flush data set from ?sec-r-objects would appear as a plain-text file (I’ve added a value column):\n\"card\", \"suit\", \"value\"\n\"ace\", \"spades\", 14\n\"king\", \"spades\", 13\n\"queen\", \"spades\", 12\n\"jack\", \"spades\", 11\n\"ten\", \"spades\", 10\nA plain-text file stores a table of data in a text document. Each row of the table is saved on its own line, and a simple convention is used to separate the cells within a row. Often cells are separated by a comma, but they can also be separated by a tab, a pipe delimiter (i.e., | ), or any other character. Each file only uses one method of separating cells, which minimizes confusion. Within each cell, data appears as you’d expect to see it, as words and numbers.\nAll plain-text files can be saved with the extension .txt (for text), but sometimes a file will receive a special extension that advertises how it separates data-cell entries. Since entries in the data set mentioned earlier are separated with a comma, this file would be a comma-separated-values file and would usually be saved with the extension .csv.\n\nD.3.1 read.table\nTo load a plain-text file, use read.table. The first argument of read.table should be the name of your file (if it is in your working directory), or the file path to your file (if it is not in your working directory). If the file path does not begin with your root directory, R will append it to the end of the file path that leads to your working directory.You can give read.table other arguments as well. The two most important are sep and header.\nIf the royal flush data set was saved as a file named poker.csv in your working directory, you could load it with:\npoker <- read.table(\"poker.csv\", sep = \",\", header = TRUE)\n\nD.3.1.1 sep\nUse sep to tell read.table what character your file uses to separate data entries. To find this out, you might have to open your file in a text editor and look at it. If you don’t specify a sep argument, read.table will try to separate cells whenever it comes to white space, such as a tab or space. R won’t be able to tell you if read.table does this correctly or not, so rely on it at your own risk.\n\n\nD.3.1.2 header\nUse header to tell read.table whether the first line of the file contains variable names instead of values. If the first line of the file is a set of variable names, you should set header = TRUE.\n\n\nD.3.1.3 na.strings\nOftentimes data sets will use special symbols to represent missing information. If you know that your data uses a certain symbol to represent missing entries, you can tell read.table (and the preceding functions) what the symbol is with the na.strings argument. read.table will convert all instances of the missing information symbol to NA, which is R’s missing information symbol (see Missing Information).\nFor example, your poker data set contained missing values stored as a ., like this:\n## \"card\",\"suit\",\"value\"\n## \"ace\",\" spades\",\" 14\"\n## \"king\",\" spades\",\" 13\"\n## \"queen\",\".\",\".\"\n## \"jack\",\".\",\".\"\n## \"ten\",\".\",\".\"\nYou could read the data set into R and convert the missing values into NAs as you go with the command:\npoker <- read.table(\"poker.csv\", sep = \",\", header = TRUE, na.string = \".\")\nR would save a version of poker that looks like this:\n##  card    suit value\n##   ace  spades    14\n##  king  spades    13\n## queen    <NA>    NA\n##  jack    <NA>    NA\n##   ten    <NA>    NA\n\n\nD.3.1.4 skip and nrow\nSometimes a plain-text file will come with introductory text that is not part of the data set. Or, you may decide that you only wish to read in part of a data set. You can do these things with the skip and nrow arguments. Use skip to tell R to skip a specific number of lines before it starts reading in values from the file. Use nrow to tell R to stop reading in values after it has read in a certain number of lines.\nFor example, imagine that the complete royal flush file looks like this:\nThis data was collected by the National Poker Institute. \nWe accidentally repeated the last row of data.\n\n\"card\", \"suit\", \"value\"\n\"ace\", \"spades\", 14\n\"king\", \"spades\", 13\n\"queen\", \"spades\", 12\n\"jack\", \"spades\", 11\n\"ten\", \"spades\", 10\n\"ten\", \"spades\", 10\nYou can read just the six lines that you want (five rows plus a header) with:\nread.table(\"poker.csv\", sep = \",\", header = TRUE, skip = 3, nrow = 5)\n##    card    suit value\n## 1   ace  spades    14\n## 2  king  spades    13\n## 3 queen  spades    12\n## 4  jack  spades    11\n## 5   ten  spades    10\nNotice that the header row doesn’t count towards the total rows allowed by nrow.\n\n\nD.3.1.5 stringsAsFactors\nR reads in numbers just as you’d expect, but when R comes across character strings (e.g., letters and words) it begins to act strangely. R wants to convert every character string into a factor. This is R’s default behavior, but I think it is a mistake. Sometimes factors are useful. At other times, they’re clearly the wrong data type for the job. Also factors cause weird behavior, especially when you want to display data. This behavior can be surprising if you didn’t realize that R converted your data to factors. In general, you’ll have a smoother R experience if you don’t let R make factors until you ask for them. Thankfully, it is easy to do this.\nSetting the argument stringsAsFactors to FALSE will ensure that R saves any character strings in your data set as character strings, not factors. To use stringsAsFactors, you’d write:\nread.table(\"poker.csv\", sep = \",\", header = TRUE, stringsAsFactors = FALSE)\nIf you will be loading more than one data file, you can change the default factoring behavior at the global level with:\noptions(stringsAsFactors = FALSE)\nThis will ensure that all strings will be read as strings, not as factors, until you end your R session, or rechange the global default by running:\noptions(stringsAsFactors = TRUE)\n\n\n\nD.3.2 The read Family\nR also comes with some prepackaged short cuts for read.table, shown in Table D.1.\n\n\nTable D.1: R’s read functions. You can overwrite any of the default arguments as necessary.\n\n\n\n\n\n\n\nFunction\nDefaults\nUse\n\n\n\n\nread.table\nsep = ” “, header = FALSE\nGeneral-purpose read function\n\n\nread.csv\nsep = “,”, header = TRUE\nComma-separated-variable (CSV) files\n\n\nread.delim\nsep = “, header = TRUE\nTab-delimited files\n\n\nread.csv2\nsep = “;”, header = TRUE, dec = “,”\nCSV files with European decimal format\n\n\nread.delim2\nsep = “, header = TRUE, dec =”,”\nTab-delimited files with European decimal format\n\n\n\n\nThe first shortcut, read.csv, behaves just like read.table but automatically sets sep = \",\" and header = TRUE, which can save you some typing:\npoker <- read.csv(\"poker.csv\")\nread.delim automatically sets sep to the tab character, which is very handy for reading tab delimited files. These are files where each cell is separated by a tab. read.delim also sets header = TRUE by default.\nread.delim2 and read.csv2 exist for European R users. These functions tell R that the data uses a comma instead of a period to denote decimal places. (If you’re wondering how this works with CSV files, CSV2 files usually separate cells with a semicolon, not a comma.)\n\n\n\n\n\n\nImport Dataset\n\n\n\nYou can also load plain text files with RStudio’s Import Dataset button, as described in Loading Data. Import Dataset provides a GUI version of read.table.\n\n\n\n\nD.3.3 read.fwf\nOne type of plain-text file defies the pattern by using its layout to separate data cells. Each row is placed in its own line (as with other plain-text files), and then each column begins at a specific number of characters from the lefthand side of the document. To achieve this, an arbitrary number of character spaces is added to the end of each entry to correctly position the next entry. These documents are known as fixed-width files and usually end with the extension .fwf.\nHere’s one way the royal flush data set could look as a fixed-width file. In each row, the suit entry begins exactly 10 characters from the start of the line. It doesn’t matter how many characters appeared in the first cell of each row:\ncard      suit       value\nace       spades     14\nking      spades     13  \nqueen     spades     12  \njack      spades     11  \n10        spades     10\nFixed-width files look nice to human eyes (but no better than a tab-delimited file); however, they can be difficult to work with. Perhaps because of this, R comes with a function for reading fixed-width files, but no function for saving them. Unfortunately, US government agencies seem to like fixed-width files, and you’ll likely encounter one or more during your career.\nYou can read fixed-width files into R with the function read.fwf. The function takes the same arguments as read.table but requires an additional argument, widths, which should be a vector of numbers. Each _i_th entry of the widths vector should state the width (in characters) of the _i_th column of the data set.\nIf the aforementioned fixed-width royal flush data was saved as poker.fwf in your working directory, you could read it with:\npoker <- read.fwf(\"poker.fwf\", widths = c(10, 7, 6), header = TRUE)\n\n\nD.3.4 HTML Links\nMany data files are made available on the Internet at their own web address. If you are connected to the Internet, you can open these files straight into R with read.table, read.csv, etc. You can pass a web address into the file name argument for any of R’s data-reading functions. As a result, you could read in the poker data set from a web address like http://…/poker.csv with:\npoker <- read.csv(\"http://.../poker.csv\")\nThat’s obviously not a real address, but here’s something that would work—if you can manage to type it!\ndeck <- read.csv(\"https://gist.githubusercontent.com/garrettgman/9629323/raw/ee5dfc039fd581cb467cc69c226ea2524913c3d8/deck.csv\")\nJust make sure that the web address links directly to the file and not to a web page that links to the file. Usually, when you visit a data file’s web address, the file will begin to download or the raw data will appear in your browser window.\nNote that websites that begin with _https://_ are secure websites, which means R may not be able to access the data provided at these links.\n\n\nD.3.5 Saving Plain-Text Files\nOnce your data is in R, you can save it to any file format that R supports. If you’d like to save it as a plain-text file, you can use the +write+ family of functions. The three basic write functions appear in Table D.2. Use write.csv to save your data as a .csv file and write.table to save your data as a tab delimited document or a document with more exotic separators.\n\n\nTable D.2: R saves data sets to plain-text files with the write family of functions\n\n\n\n\n\n\nFile format\nFunction and syntax\n\n\n\n\n.csv\nwrite.csv(r_object, file = filepath, row.names = FALSE)\n\n\n.csv (with European decimal notation)\nwrite.csv2(r_object, file = filepath, row.names = FALSE)\n\n\ntab delimited\nwrite.table(r_object, file = filepath, sep = \"\\t\", row.names=FALSE)\n\n\n\n\nThe first argument of each function is the R object that contains your data set. The file argument is the file name (including extension) that you wish to give the saved data. By default, each function will save your data into your working directory. However, you can supply a file path to the file argument. R will oblige by saving the file at the end of the file path. If the file path does not begin with your root directory, R will append it to the end of the file path that leads to your working directory.\nFor example, you can save the (hypothetical) poker data frame to a subdirectory named data within your working directory with the command:\nwrite.csv(poker, \"data/poker.csv\", row.names = FALSE)\nKeep in mind that write.csv and write.table cannot create new directories on your computer. Each folder in the file path must exist before you try to save a file with it.\nThe row.names argument prevents R from saving the data frame’s row names as a column in the plain-text file. You might have noticed that R automatically names each row in a data frame with a number. For example, each row in our poker data frame appears with a number next to it:\npoker\n##    card   suit value\n## 1   ace spades    14\n## 2  king spades    13\n## 3 queen spades    12\n## 4  jack spades    11\n## 5    10 spades    10\nThese row numbers are helpful, but can quickly accumulate if you start saving them. R will add a new set of numbers by default each time you read the file back in. Avoid this by always setting row.names = FALSE when you use a function in the write family.\n\n\nD.3.6 Compressing Files\nTo compress a plain-text file, surround the file name or file path with the function bzfile, gzfile, or xzfile. For example:\nwrite.csv(poker, file = bzfile(\"data/poker.csv.bz2\"), row.names = FALSE)\nEach of these functions will compress the output with a different type of compression format, shown in Table D.3.\n\n\nTable D.3: R comes with three helper functions for compressing files\n\n\nFunction\nCompression type\n\n\n\n\nbzfile\nbzip2\n\n\ngzfile\ngnu zip (gzip)\n\n\nxzfile\nxz compression\n\n\n\n\nIt is a good idea to adjust your file’s extension to reflect the compression. R’s read functions will open plain-text files compressed in any of these formats. For example, you could read a compressed file named poker.csv.bz2 with:\nread.csv(\"poker.csv.bz2\")\nor:\nread.csv(\"data/poker.csv.bz2\")\ndepending on where the file is saved."
  },
  {
    "objectID": "a4-data.html#r-files",
    "href": "a4-data.html#r-files",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.4 R Files",
    "text": "D.4 R Files\nR provides two file formats of its own for storing data, .RDS and .RData. RDS files can store a single R object, and RData files can store multiple R objects.\nYou can open a RDS file with readRDS. For example, if the royal flush data was saved as poker.RDS, you could open it with:\npoker <- readRDS(\"poker.RDS\")\nOpening RData files is even easier. Simply run the function load with the file:\nload(\"file.RData\")\nThere’s no need to assign the output to an object. The R objects in your RData file will be loaded into your R session with their original names. RData files can contain multiple R objects, so loading one may read in multiple objects. load doesn’t tell you how many objects it is reading in, nor what their names are, so it pays to know a little about the RData file before you load it.\nIf worse comes to worst, you can keep an eye on the environment pane in RStudio as you load an RData file. It displays all of the objects that you have created or loaded during your R session. Another useful trick is to put parentheses around your load command like so, (load(\"poker.RData\")). This will cause R to print out the names of each object it loads from the file.\nBoth readRDS and load take a file path as their first argument, just like R’s other read and write functions. If your file is in your working directory, the file path will be the file name.\n\nD.4.1 Saving R Files\nYou can save an R object like a data frame as either an RData file or an RDS file. RData files can store multiple R objects at once, but RDS files are the better choice because they foster reproducible code.\nTo save data as an RData object, use the save function. To save data as a RDS object, use the saveRDS function. In each case, the first argument should be the name of the R object you wish to save. You should then include a file argument that has the file name or file path you want to save the data set to.\nFor example, if you have three R objects, a, b, and c, you could save them all in the same RData file and then reload them in another R session:\na <- 1\nb <- 2\nc <- 3\nsave(a, b, c, file = \"stuff.RData\")\nload(\"stuff.RData\")\nHowever, if you forget the names of your objects or give your file to someone else to use, it will be difficult to determine what was in the file—even after you (or they) load it. The user interface for RDS files is much more clear. You can save only one object per file, and whoever loads it can decide what they want to call their new data. As a bonus, you don’t have to worry about load overwriting any R objects that happened to have the same name as the objects you are loading:\nsaveRDS(a, file = \"stuff.RDS\") \na <- readRDS(\"stuff.RDS\")\nSaving your data as an R file offers some advantages over saving your data as a plain-text file. R automatically compresses the file and will also save any R-related metadata associated with your object. This can be handy if your data contains factors, dates and times, or class attributes. You won’t have to reparse this information into R the way you would if you converted everything to a text file.\nOn the other hand, R files cannot be read by many other programs, which makes them inefficient for sharing. They may also create a problem for long-term storage if you don’t think you’ll have a copy of R when you reopen the files."
  },
  {
    "objectID": "a4-data.html#excel-spreadsheets",
    "href": "a4-data.html#excel-spreadsheets",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.5 Excel Spreadsheets",
    "text": "D.5 Excel Spreadsheets\nMicrosoft Excel is a popular spreadsheet program that has become almost industry standard in the business world. There is a good chance that you will need to work with an Excel spreadsheet in R at least once in your career. You can read spreadsheets into R and also save R data as a spreadsheet in a variety of ways.\n\nD.5.1 Export from Excel\nThe best method for moving data from Excel to R is to export the spreadsheet from Excel as a .csv or .txt file. Not only will R be able to read the text file, so will any other data analysis software. Text files are the lingua franca of data storage.\nExporting the data solves another difficulty as well. Excel uses proprietary formats and metadata that will not easily transfer into R. For example, a single Excel file can include multiple spreadsheets, each with their own columns and macros. When Excel exports the file as a .csv or .txt, it makes sure this format is transferred into a plain-text file in the most appropriate way. R may not be able to manage the conversion as efficiently.\nTo export data from Excel, open the Excel spreadsheet and then go to Save As in the Microsoft Office Button menu. Then choose CSV in the Save as type box that appears and save the files. You can then read the file into R with the read.csv function.\n\n\nD.5.2 Copy and Paste\nYou can also copy portions of an Excel spreadsheet and paste them into R. To do this, open the spreadsheet and select the cells you wish to read into R. Then select Edit > Copy in the menu bar—or use a keyboard shortcut—to copy the cells to your clipboard.\nOn most operating systems, you can read the data stored in your clipboard into R with:\nread.table(\"clipboard\")\nOn Macs you will need to use:\nread.table(pipe(\"pbpaste\"))\nIf the cells contain values with spaces in them, this will disrupt read.table. You can try another read function (or just formally export the data from Excel) before reading it into R.\n\n\nD.5.3 XLConnect\nMany packages have been written to help you read Excel files directly into R. Unfortunately, many of these packages do not work on all operating systems. Others have been made out of date by the .xlsx file format. One package that does work on all file systems (and gets good reviews) is the XLConnect package. To use it, you’ll need to install and load the package:\ninstall.packages(\"XLConnect\")\nlibrary(XLConnect)\nXLConnect relies on Java to be platform independent. So when you first open XLConnect, RStudio may ask to download a Java Runtime Environment if you do not already have one.\n\n\nD.5.4 Reading Spreadsheets\nYou can use XLConnect to read in an Excel spreadsheet with either a one- or a two-step process. I’ll start with the two-step process. First, load an Excel workbook with loadWorkbook. loadWorkbook can load both .xls and .xlsx files. It takes one argument: the file path to your Excel workbook (this will be the name of the workbook if it is saved in your working directory):\nwb <- loadWorkbook(\"file.xlsx\")\nNext, read a spreadsheet from the workbook with readWorksheet, which takes several arguments. The first argument should be a workbook object created with loadWorkbook. The next argument, sheet, should be the name of the spreadsheet in the workbook that you would like to read into R. This will be the name that appears on the bottom tab of the spreadsheet. You can also give sheet a number, which specifies the sheet that you want to read in (one for the first sheet, two for the second, and so on).\nreadWorksheet then takes four arguments that specify a bounding box of cells to read in: startRow, startCol, endRow, and endCol. Use startRow and startCol to describe the cell in the top-left corner of the bounding box of cells that you wish to read in. Use endRow and endCol to specify the cell in the bottom-right corner of the bounding box. Each of these arguments takes a number. If you do not supply bounding arguments, readWorksheet will read in the rectangular region of cells in the spreadsheet that appears to contain data. readWorksheet will assume that this region contains a header row, but you can tell it otherwise with header = FALSE.\nSo to read in the first worksheet from wb, you could use:\nsheet1 <- readWorksheet(wb, sheet = 1, startRow = 0, startCol = 0, \n  endRow = 100, endCol = 3)\nR will save the output as a data frame. All of the arguments in readWorkbook except the first are vectorized, so you can use it to read in multiple sheets from the same workbook at once (or multiple cell regions from a single worksheet). In this case, readWorksheet will return a list of data frames.\nYou can combine these two steps with readWorksheetFromFile. It takes the file argument from loadWorkbook and combines it with the arguments from readWorksheet. You can use it to read one or more sheets straight from an Excel file:\nsheet1 <- readWorksheetFromFile(\"file.xlsx\", sheet = 1, startRow = 0, \n  startCol = 0, endRow = 100, endCol = 3)\n\n\nD.5.5 Writing Spreadsheets\nWriting to an Excel spreadsheet is a four-step process. First, you need to set up a workbook object with loadWorkbook. This works just as before, except if you are not using an existing Excel file, you should add the argument create = TRUE. XLConnect will create a blank workbook. When you save it, XLConnect will write it to the file location that you specified here with loadWorkbook:\nwb <- loadWorkbook(\"file.xlsx\", create = TRUE)\nNext, you need to create a worksheet inside your workbook object with createSheet. Tell createSheet which workbook to place the sheet in and which to use for the sheet.\ncreateSheet(wb, \"Sheet 1\")\nThen you can save your data frame or matrix to the sheet with writeWorksheet. The first argument of writeWorksheet, object, is the workbook to write the data to. The second argument, data, is the data to write. The third argument, sheet, is the name of the sheet to write it to. The next two arguments, startRow and startCol, tell R where in the spreadsheet to place the upper-left cell of the new data. These arguments each default to 1. Finally, you can use header to tell R whether your column names should be written with the data:\nwriteWorksheet(wb, data = poker, sheet = \"Sheet 1\")\nOnce you have finished adding sheets and data to your workbook, you can save it by running saveWorkbook on the workbook object. R will save the workbook to the file name or path you provided in loadWorkbook. If this leads to an existing Excel file, R will overwrite it. If it leads to a new file, R will create it.\nYou can also collapse these steps into a single call with writeWorksheetToFile, like this:\nwriteWorksheetToFile(\"file.xlsx\", data = poker, sheet = \"Sheet 1\", \n  startRow = 1, startCol = 1)\nThe XLConnect package also lets you do more advanced things with Excel spreadsheets, such as writing to a named region in a spreadsheet, working with formulas, and assigning styles to cells. You can read about these features in XLConnect’s vignette, which is accessible by loading XLConnect and then running:\nvignette(\"XLConnect\")"
  },
  {
    "objectID": "a4-data.html#loading-files-from-other-programs",
    "href": "a4-data.html#loading-files-from-other-programs",
    "title": "Appendix D — Loading and Saving Data in R",
    "section": "D.6 Loading Files from Other Programs",
    "text": "D.6 Loading Files from Other Programs\nYou should follow the same advice I gave you for Excel files whenever you wish to work with file formats native to other programs: open the file in the original program and export the data as a plain-text file, usually a CSV. This will ensure the most faithful transcription of the data in the file, and it will usually give you the most options for customizing how the data is transcribed.\nSometimes, however, you may acquire a file but not the program it came from. As a result, you won’t be able to open the file in its native program and export it as a text file. In this case, you can use one of the functions in Table D.4 to open the file. These functions mostly come in R’s foreign package. Each attempts to read in a different file format with as few hiccups as possible.\n\n\nTable D.4: A number of functions will attempt to read the file types of other data-analysis programs\n\n\nFile format\nFunction\nLibrary\n\n\n\n\nERSI ArcGIS\nread.shapefile\nshapefiles\n\n\nMatlab\nreadMat\nR.matlab\n\n\nminitab\nread.mtp\nforeign\n\n\nSAS (permanent data set)\nread.ssd\nforeign\n\n\nSAS (XPORT format)\nread.xport\nforeign\n\n\nSPSS\nread.spss\nforeign\n\n\nStata\nread.dta\nforeign\n\n\nSystat\nread.systat\nforeign\n\n\n\n\n\nD.6.1 Connecting to Databases\nYou can also use R to connect to a database and read in data.\nUse the RODBC package to connect to databases through an ODBC connection.\nUse the DBI package to connect to databases through individual drivers. The DBI package provides a common syntax for working with different databases. You will have to download a database-specific package to use in conjunction with DBI. These packages provide the API for the native drivers of different database programs. For MySQL use RMySQL, for SQLite use RSQLite, for Oracle use ROracle, for PostgreSQL use RPostgreSQL, and for databases that use drivers based on the Java Database Connectivity (JDBC) API use RJDBC. Once you have loaded the appropriate driver package, you can use the commands provided by DBI to access your database."
  },
  {
    "objectID": "a5-debug.html",
    "href": "a5-debug.html",
    "title": "Appendix E — Debugging R Code",
    "section": "",
    "text": "Note\n\n\n\nThis appendix refers to environments, the topic of Environments, and uses examples from Programs and S3. You should read through these chapters first to get the most out of this appendix.\nR comes with a simple set of debugging tools that RStudio amplifies. You can use these tools to better understand code that produces an error or returns an unexpected result. Usually this will be your own code, but you can also examine the functions in R or one of its packages.\nDebugging code can take as much creativity and insight as writing code. There is no guarantee that you will find a bug or be able to fix it when you do. However, you can help yourself by using R’s debugging tools. These include the traceback, browser, debug, debugonce, trace, and recover functions.\nUsing these tools is usually a two-step process. First, you locate where an error occurred. Then you try to determine why it occurred. You can do the first step with R’s traceback function."
  },
  {
    "objectID": "a5-debug.html#traceback",
    "href": "a5-debug.html#traceback",
    "title": "Appendix E — Debugging R Code",
    "section": "E.1 traceback",
    "text": "E.1 traceback\nThe traceback tool pinpoints the location of an error. Many R functions call other R functions, which call other functions, and so on. When an error occurs, it may not be clear which of these functions went wrong. Let’s consider an example. The following functions call one another, and the last function creates an error (you’ll see why in a second):\nfirst <- function() second()\nsecond <- function() third()\nthird <- function() fourth()\nfourth <- function() fifth()\nfifth <- function() bug()\nWhen you run first, it will call second, which will call third, which will call fourth, which will call fifth, which will call bug, a function that does not exist. Here’s what that will look like at the command line:\nfirst()\n##  Error in fifth() : could not find function \"bug\" \nThe error report tells us that the error occurred when R tried to run fifth. It also tells us the nature of the error (there is no function called bug). Here, it is obvious why R calls fifth, but it might not be so obvious why R calls a function when an error occurs in the wild.\nYou can see the path of functions that R called before it hit an error by typing traceback() at the command line. traceback will return a call stack, a list of the functions that R called in the order that it called them. The bottom function will be the command that you entered in the command line. The top function will be the function that caused the error:\ntraceback()\n## 5: fifth() at #1\n## 4: fourth() at #1\n## 3: third() at #1\n## 2: second() at #1\n## 1: first()\ntraceback will always refer to the last error you encountered. If you would like to look at a less recent error, you will need to recreate it before running traceback.\nHow can this help you? First, traceback returns a list of suspects. One of these functions caused the error, and each function is more suspicious than the ones below it. Chances are that our bug came from fifth (it did), but it is also possible that an earlier function did something odd—like call fifth when it shouldn’t have.\nSecond, traceback can show you if R stepped off the path that you expected it to take. If this happened, look at the last function before things went wrong.\nThird, traceback can reveal the frightening extent of infinite recursion errors. For example, if you change fifth so that it calls second, the functions will make a loop: second will call third, which will call fourth, which will call fifth, which will call second and start the loop over again. It is easier to do this sort of thing in practice than you might think:\nfifth <- function() second()\nWhen you call first(), R will start to run the functions. After awhile, it will notice that it is repeating itself and will return an error. traceback will show just what R was doing:\nfirst()\n## Error: evaluation nested too deeply: infinite recursion/options(expressions=)?\n\ntraceback()\n## 5000: fourth() at #1\n## 4999: third() at #1\n## 4998: second() at #1\n## 4997: fifth() at #1\n## 4996: fourth() at #1\n## 4995: third() at #1\n## 4994: second() at #1\n## 4993: fifth() at #1\n## ...\nNotice that there are 5,000 lines of output in this traceback. If you are using RStudio, you will not get to see the traceback of an infinite recursion error (I used the Mac GUI to get this output). RStudio represses the traceback for infinite recursion errors to prevent the large call stacks from pushing your console history out of R’s memory buffer. With RStudio, you will have to recognize the infinite recursion error by its error message. However, you can still see the imposing traceback by running things in a UNIX shell or the Windows or Mac GUIs.\nRStudio makes it very easy to use traceback. You do not even need to type in the function name. Whenever an error occurs, RStudio will display it in a gray box with two options. The first is Show Traceback, shown in Figure E.1.\n\n\n\nFigure E.1: RStudio’s Show Traceback option.\n\n\nIf you click Show Traceback, RStudio will expand the gray box and display the traceback call stack, as in Figure E.2. The Show Traceback option will persist beside an error message in your console, even as you write new commands. This means that you can go back and look at the call stacks for all errors—not just the most recent error.\nImagine that you’ve used traceback to pinpoint a function that you think might cause a bug. Now what should you do? You should try to figure out what the function did to cause an error while it ran (if it did anything). You can examine how the function runs with browser.\n\n\n\nFigure E.2: RStudio’s Traceback display."
  },
  {
    "objectID": "a5-debug.html#browser",
    "href": "a5-debug.html#browser",
    "title": "Appendix E — Debugging R Code",
    "section": "E.2 browser",
    "text": "E.2 browser\nYou can ask R to pause in the middle of running a function and give control back to you with browser. This will let you enter new commands at the command line. The active environment for these commands will not be the global environment (as usual); it will be the runtime environment of the function that you have paused. As a result, you can look at the objects that the function is using, look up their values with the same scoping rules that the function would use, and run code under the same conditions that the function would run it in. This arrangement provides the best chance for spotting the source of bugs in a function.\nTo use browser, add the call browser() to the body of a function and then resave the function. For example, if I wanted to pause in the middle of the score function from [Programs], I could add browser() to the body of score and then rerun the following code, which defines score:\nscore <- function (symbols) {\n  # identify case\n  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n  bars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # get prize\n  if (same) {\n    payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    prize <- unname(payouts[symbols[1]])\n  } else if (all(bars)) {\n    prize <- 5\n  } else {\n    cherries <- sum(symbols == \"C\")\n    prize <- c(0, 2, 5)[cherries + 1]\n  }\n  \n  browser()\n\n  # adjust for diamonds\n  diamonds <- sum(symbols == \"DD\")\n  prize * 2 ^ diamonds\n}\nNow whenever R runs score, it will come to the call browser(). You can see this with the play function from [Programs]. If you don’t have play handy, you can access it by running this code:\nget_symbols <- function() {\n  wheel <- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\n  sample(wheel, size = 3, replace = TRUE, \n    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))\n}\n\nplay <- function() {\n  symbols <- get_symbols()\n  structure(score(symbols), symbols = symbols, class = \"slots\")\n}\nWhen you run play, play will call get_symbols and then score. As R works through score, it will come across the call to browser and run it. When R runs this call, several things will happen, as in Figure E.3. First, R will stop running score. Second, the command prompt will change to browser[1]> and R will give me back control; I can now type new commands in at the new command prompt. Third, three buttons will appear above the console pane: Next, Continue, and Stop. Fourth, RStudio will display the source code for score in the scripts pane, and it will highlight the line that contains browser(). Fifth, the environments tab will change. Instead of revealing the objects that are saved in the global environment, it will reveal the objects that are saved in the runtime environment of score (see [Environments] for an explanation of R’s environment system). Sixth, RStudio will open a new Traceback pane, which shows the call stack RStudio took to get to browser. The most recent function, score, will be highlighted.\nI’m now in a new R mode, called browser mode. Browser mode is designed to help you uncover bugs, and the new display in RStudio is designed to help you navigate this mode.\nAny command that you run in browser mode will be evaluated in the context of the runtime environment of the function that called browser. This will be the function that is highlighted in the new Traceback pane. Here, that function is score. So while we are in browser mode, the active environment will be score’s runtime environment. This lets you do two things.\n\n\n\nFigure E.3: RStudio updates its display whenever you enter browser mode to help you navigate the mode.\n\n\nFirst, you can inspect the objects that score uses. The updated Environments pane shows you which objects score has saved in its local environment. You can inspect any of them by typing their name at the browser prompt. This gives you a way to see the values of runtime variables that you normally would not be able to access. If a value looks clearly wrong, you may be close to finding a bug:\nBrowse[1]> symbols\n## [1] \"B\" \"B\" \"0\"\n\nBrowse[1]> same\n## [1] FALSE\nSecond, you can run code and see the same results that score would see. For example, you could run the remaining lines of the score function and see if they do anything unusual. You could run these lines by typing them into the command prompt, or you could use the three navigation buttons that now appear above the prompt, as in Figure E.4.\nThe first button, Next, will run the next line of code in score. The highlighted line in the scripts pane will advance by one line to show you your new location in the score function. If the next line begins a code chunk, like a for loop or an if tree, R will run the whole chunk and will highlight the whole chunk in the script window.\nThe second button, Continue, will run all of the remaining lines of score and then exit the browser mode.\nThe third button, Stop, will exit browser mode without running any more lines of score.\n\n\n\nFigure E.4: You can navigate browser mode with the three buttons at the top of the console pane.\n\n\nYou can do the same things by typing the commands n, c, and Q into the browser prompt. This creates an annoyance: what if you want to look up an object named n, c, or Q? Typing in the object name will not work, R will either advance, continue, or quit the browser mode. Instead you will have to look these objects up with the commands get(\"n\"), get(\"c\"), and get(\"Q\"). cont is a synonym for c in browser mode and where prints the call stack, so you’ll have to look up these objects with get as well.\nBrowser mode can help you see things from the perspective of your functions, but it cannot show you where the bug lies. However, browser mode can help you test hypotheses and investigate function behavior. This is usually all you need to spot and fix a bug. The browser mode is the basic debugging tool of R. Each of the following functions just provides an alternate way to enter the browser mode.\nOnce you fix the bug, you should resave your function a third time—this time without the browser() call. As long as the browser call is in there, R will pause each time you, or another function, calls score."
  },
  {
    "objectID": "a5-debug.html#break-points",
    "href": "a5-debug.html#break-points",
    "title": "Appendix E — Debugging R Code",
    "section": "E.3 Break Points",
    "text": "E.3 Break Points\nRStudio’s break points provide a graphical way to add a browser statement to a function. To use them, open the script where you’ve defined a function. Then click to the left of the line number of the line of code in the function body where you’d like to add the browser statement. A hollow red dot will appear to show you where the break point will occur. Then run the script by clicking the Source button at the top of the Scripts pane. The hollow dot will turn into a solid red dot to show that the function has a break point (see Figure E.5).\nR will treat the break point like a browser statement, going into browser mode when it encounters it. You can remove a break point by clicking on the red dot. The dot will disappear, and the break point will be removed.\n\n\n\nFigure E.5: Break points provide the graphical equivalent of a browser statement.\n\n\nBreak points and browser provide a great way to debug functions that you have defined. But what if you want to debug a function that already exists in R? You can do that with the debug function."
  },
  {
    "objectID": "a5-debug.html#debug",
    "href": "a5-debug.html#debug",
    "title": "Appendix E — Debugging R Code",
    "section": "E.4 debug",
    "text": "E.4 debug\nYou can “add” a browser call to the very start of a preexisting function with debug. To do this, run debug on the function. For example, you can run debug on sample with:\ndebug(sample)\nAfterward, R will act as if there is a browser() statement in the first line of the function. Whenever R runs the function, it will immediately enter browser mode, allowing you to step through the function one line at a time. R will continue to behave this way until you “remove” the browser statement with undebug:\nundebug(sample)\nYou can check whether a function is in “debugging” mode with isdebugged. This will return TRUE if you’ve ran debug on the function but have yet to run undebug:\nisdebugged(sample)\n## FALSE\nIf this is all too much of a hassle, you can do what I do and use debugonce instead of debug. R will enter browser mode the very next time it runs the function but will automatically undebug the function afterward. If you need to browse through the function again, you can just run debugonce on it a second time.\nYou can recreate debugonce in RStudio whenever an error occurs. “Rerun with debug” will appear in the grey error box beneath Show Traceback (Figure E.1). If you click this option, RStudio will rerun the command as if you had first run debugonce on it. R will immediately go into browser mode, allowing you to step through the code. The browser behavior will only occur on this run of the code. You do not need to worry about calling undebug when you are done."
  },
  {
    "objectID": "a5-debug.html#trace",
    "href": "a5-debug.html#trace",
    "title": "Appendix E — Debugging R Code",
    "section": "E.5 trace",
    "text": "E.5 trace\nYou can add the browser statement further into the function, and not at the very start, with trace. trace takes the name of a function as a character string and then an R expression to insert into the function. You can also provide an at argument that tells trace at which line of the function to place the expression. So to insert a browser call at the fourth line of sample, you would run:\ntrace(\"sample\", browser, at = 4)\nYou can use trace to insert other R functions (not just browser) into a function, but you may need to think of a clever reason for doing so. You can also run trace on a function without inserting any new code. R will prints trace:<the function> at the command line every time R runs the function. This is a great way to test a claim I made in [S3], that R calls print every time it displays something at the command line:\ntrace(print)\n\nfirst\n## trace: print(function () second())\n## function() second()\n\nhead(deck)\n## trace: print\n##    face   suit value\n## 1  king spades    13\n## 2 queen spades    12\n## 3  jack spades    11\n## 4   ten spades    10\n## 5  nine spades     9\n## 6 eight spades     8\nYou can revert a function to normal after calling trace on it with untrace:\nuntrace(sample)\nuntrace(print)"
  },
  {
    "objectID": "a5-debug.html#recover",
    "href": "a5-debug.html#recover",
    "title": "Appendix E — Debugging R Code",
    "section": "E.6 recover",
    "text": "E.6 recover\nThe recover function provides one final option for debugging. It combines the call stack of traceback with the browser mode of browser. You can use recover just like browser, by inserting it directly into a function’s body. Let’s demonstrate recover with the fifth function:\nfifth <- function() recover()\nWhen R runs recover, it will pause and display the call stack, but that’s not all. R gives you the option of opening a browser mode in any of the functions that appear in the call stack. Annoyingly, the call stack will be displayed upside down compared to traceback. The most recent function will be on the bottom, and the original function will be on the top:\nfirst()\n## \n## Enter a frame number, or 0 to exit   \n## \n## 1: first()\n## 2: #1: second()\n## 3: #1: third()\n## 4: #1: fourth()\n## 5: #1: fifth()\nTo enter a browser mode, type in the number next to the function in whose runtime environment you would like to browse. If you do not wish to browse any of the functions, type 0:\n3\n## Selection: 3\n## Called from: fourth()\n## Browse[1]> \nYou can then proceed as normal. recover gives you a chance to inspect variables up and down your call stack and is a powerful tool for uncovering bugs. However, adding recover to the body of an R function can be cumbersome. Most R users use it as a global option for handling errors.\nIf you run the following code, R will automatically call recover() whenever an error occurs:\noptions(error = recover)\nThis behavior will last until you close your R session, or reverse the behavior by calling:\noptions(error = NULL)"
  }
]